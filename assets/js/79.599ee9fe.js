(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{698:function(e,v,a){"use strict";a.r(v);var t=a(33),_=Object(t.a)({},(function(){var e=this,v=e.$createElement,a=e._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"作用与解释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用与解释"}},[e._v("#")]),e._v(" 作用与解释")]),e._v(" "),a("p",[e._v('java.util.regex.Pattern类的实例的主要作用是给正则表达式一个匹配模式，因为在java里面正则表达式是一个字符串，字符串的能力是非常有限的，不像javascript那样可以在正则表达式末尾添加"g" "i" "m"来指定全局匹配、区分大小写匹配和多行匹配（如"/\\b\\w/gi"）。因此在java里面需要Pattern实例来包装正则表达式zifu字符串，然后通过Pattern实例的方法来设置·匹配模式。')]),e._v(" "),a("h1",{attrs:{id:"方法详细信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法详细信息"}},[e._v("#")]),e._v(" 方法详细信息")]),e._v(" "),a("h2",{attrs:{id:"pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pattern"}},[e._v("#")]),e._v(" pattern")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Pattern pattern()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回该匹配器解释的模式。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("该匹配器创建的模式")])])]),e._v(" "),a("h2",{attrs:{id:"tomatchresult"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tomatchresult"}},[e._v("#")]),e._v(" toMatchResult")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public MatchResult toMatchResult()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("将此匹配器的匹配状态返回为"),a("RouterLink",{attrs:{to:"/java/util/regex/MatchResult.html"}},[a("code",[e._v("MatchResult")])]),e._v("  。 结果不受在此匹配器上执行的后续操作的影响。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("一个 "),a("code",[e._v("MatchResult")]),e._v("与这个匹配器的状态")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"usepattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usepattern"}},[e._v("#")]),e._v(" usePattern")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher usePattern(Pattern newPattern)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("更改"),a("code",[e._v("Pattern")]),e._v("这个"),a("code",[e._v("Matcher")]),e._v("用于查找匹配。")]),e._v(" "),a("p",[e._v("此方法会导致此匹配器丢失有关发生的最后一个匹配的组的信息。  匹配器在输入中的位置得到维护，其最后一个附加位置不受影响。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("newPattern")]),e._v(" - 该匹配器使用的新模式")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalArgumentException")]),e._v("  - 如果newPattern是 "),a("code",[e._v("null")])])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"reset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[e._v("#")]),e._v(" reset")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher reset()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("重设此匹配器。")]),e._v(" "),a("p",[e._v("重置匹配器会丢弃其所有的显式状态信息，并将其附加位置设置为零。  匹配器的区域设置为默认区域，它是其整个字符序列。 该匹配器区域边界的锚定和透明度不受影响。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])])]),e._v(" "),a("h2",{attrs:{id:"reset-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset-2"}},[e._v("#")]),e._v(" reset")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher reset(CharSequence input)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("使用新的输入序列重置此匹配器。")]),e._v(" "),a("p",[e._v("重置匹配器会丢弃其所有的显式状态信息，并将其附加位置设置为零。  匹配器的区域设置为默认区域，它是其整个字符序列。 该匹配器区域边界的锚定和透明度不受影响。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("input")]),e._v(" - 新的输入字符序列")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])])]),e._v(" "),a("h2",{attrs:{id:"start"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#start"}},[e._v("#")]),e._v(" start")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int start()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回上一个匹配的起始索引。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("start")]),e._v("在界面  "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("第一个字符的索引匹配")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一匹配操作失败")])])]),e._v(" "),a("h2",{attrs:{id:"start-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#start-2"}},[e._v("#")]),e._v(" start")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int start(int group)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回给定组在上一个匹配操作期间捕获的子序列的开始索引。")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/01.Java/01.Java基础/23.正则表达式/Pattern.html#cg"}},[e._v("Capturing groups从左到右")]),e._v("索引，从一开始。  组零表示整个模式，所以表达式"),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("start(0)")]),e._v("相当于"),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("start()")]),e._v(" 。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("start")]),e._v("在接口  "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("group")]),e._v(" - 此匹配器模式中捕获组的索引")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("该组所捕获的第一个角色的索引，或 "),a("code",[e._v("-1，")]),e._v("如果比赛是成功的，但组本身没有匹配任何东西")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一个匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IndexOutOfBoundsException")]),e._v("  - 如果在给定索引的模式中没有捕获组")])])]),e._v(" "),a("h2",{attrs:{id:"start-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#start-3"}},[e._v("#")]),e._v(" start")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int start(String name)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回给定捕获的子序列的初始索引 "),a("RouterLink",{attrs:{to:"/01.Java/01.Java基础/23.正则表达式/Pattern.html#groupname"}},[e._v("named-capturing group")]),e._v("以前的匹配操作期间。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("name")]),e._v(" - 此匹配器模式中的命名捕获组的名称")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("该组捕获的第一个角色的索引，或 "),a("code",[e._v("-1")]),e._v("如果匹配成功，但组本身不匹配任何东西")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IllegalArgumentException")]),e._v("  - 如果在给定名称的模式中没有捕获组")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.8")])])]),e._v(" "),a("h2",{attrs:{id:"end"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#end"}},[e._v("#")]),e._v(" end")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int end()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回最后一个字符匹配后的偏移量。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("end")]),e._v("中的 "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("最后一个字符匹配后的偏移量")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一匹配操作失败")])])]),e._v(" "),a("h2",{attrs:{id:"end-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#end-2"}},[e._v("#")]),e._v(" end")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int end(int group)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回在上次匹配操作期间由给定组捕获的子序列的最后一个字符之后的偏移量。")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/01.Java/01.Java基础/23.正则表达式/Pattern.html#cg"}},[e._v("Capturing groups从左到右")]),e._v("索引，从一开始。  组零表示整个模式，所以表达式"),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("end(0)")]),e._v("相当于"),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("end()")]),e._v(" 。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("end")]),e._v("在接口  "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("group")]),e._v(" - 此匹配器模式中捕获组的索引")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("组捕获的最后一个字符之后的偏移量，或 "),a("code",[e._v("-1")]),e._v("如果匹配成功但组本身没有匹配")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一个匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IndexOutOfBoundsException")]),e._v("  - 如果在给定索引的模式中没有捕获组")])])]),e._v(" "),a("h2",{attrs:{id:"end-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#end-3"}},[e._v("#")]),e._v(" end")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int end(String name)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回给定捕获子序列的最后一个字符之后的偏移量 "),a("RouterLink",{attrs:{to:"/01.Java/01.Java基础/23.正则表达式/Pattern.html#groupname"}},[e._v("named-capturing group")]),e._v("以前的匹配操作期间。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("name")]),e._v(" - 此匹配器模式中的命名捕获组的名称")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("组捕获的最后一个字符之后的偏移量，或 "),a("code",[e._v("-1")]),e._v("如果匹配成功但组本身没有匹配")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IllegalArgumentException")]),e._v("  - 如果在给定名称的模式中没有捕获组")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.8")])])]),e._v(" "),a("h2",{attrs:{id:"group"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#group"}},[e._v("#")]),e._v(" group")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public String group()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回与上一个匹配匹配的输入子序列。")]),e._v(" "),a("p",[e._v("对于具有输入序列"),a("em",[e._v("s")]),e._v("的匹配器"),a("em",[e._v("m")]),e._v(" ，表达式"),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("group()")]),e._v("和"),a("em",[e._v("s。")]),e._v(" "),a("code",[e._v("substring(")]),e._v(" "),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("start(),")]),e._v(" "),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("end())")]),e._v("是等效的。")]),e._v(" "),a("p",[e._v("请注意，某些模式，例如"),a("code",[e._v("a*")]),e._v(" ，匹配空字符串。  当模式成功匹配输入中的空字符串时，此方法将返回空字符串。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("group")]),e._v("在接口  "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("以前的匹配匹配的（可能是空的）子序列，以字符串形式")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一个匹配操作失败")])])]),e._v(" "),a("h2",{attrs:{id:"group-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#group-2"}},[e._v("#")]),e._v(" group")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public String group(int group)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回在上一次匹配操作期间由给定组捕获的输入子序列。")]),e._v(" "),a("p",[e._v("对于匹配器"),a("em",[e._v("m")]),e._v(" ，输入序列"),a("em",[e._v("s")]),e._v("和组索引"),a("em",[e._v("g")]),e._v(" ，表达式"),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("group(")]),e._v(" "),a("em",[e._v("g")]),e._v(" "),a("code",[e._v(")")]),e._v("和"),a("em",[e._v("s。")]),e._v(" "),a("code",[e._v("substring(")]),e._v(" "),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("start(")]),e._v(" "),a("em",[e._v("g")]),e._v(" "),a("code",[e._v("),")]),e._v(" "),a("em",[e._v("m。")]),e._v(" "),a("code",[e._v("end(")]),e._v(" "),a("em",[e._v("g")]),e._v(" "),a("code",[e._v("))")]),e._v("是等效的。")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/01.Java/01.Java基础/23.正则表达式/Pattern.html#cg"}},[e._v("Capturing groups从左到右")]),e._v("索引，从一开始。  组零表示整个模式，因此表达式"),a("code",[e._v("m.group(0)")]),e._v("相当于"),a("code",[e._v("m.group()")]),e._v(" 。")],1),e._v(" "),a("p",[e._v("如果匹配成功，但指定的组失败，则匹配输入序列的任何部分，则返回"),a("code",[e._v("null")]),e._v(" 。  请注意，某些组（例如"),a("code",[e._v("(a*)")]),e._v(" ）与空字符串匹配。  当这样的组成功匹配输入中的空字符串时，此方法将返回空字符串。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("group")]),e._v("在接口  "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("group")]),e._v(" - 此匹配器模式中捕获组的索引")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("在前一次匹配期间由组捕获的（可能为空的）子 "),a("code",[e._v("序列，")]),e._v("如果组未能匹配输入的一部分， "),a("code",[e._v("则为null")])])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一个匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IndexOutOfBoundsException")]),e._v("  - 如果在给定索引的模式中没有捕获组")])])]),e._v(" "),a("h2",{attrs:{id:"group-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#group-3"}},[e._v("#")]),e._v(" group")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public String group(String name)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回给定捕获的输入子序列"),a("RouterLink",{attrs:{to:"/01.Java/01.Java基础/23.正则表达式/Pattern.html#groupname"}},[e._v("named-capturing group")]),e._v("以前的匹配操作期间。")],1),e._v(" "),a("p",[e._v("如果匹配成功，但是指定的组不符合输入序列的任何部分，则返回"),a("code",[e._v("null")]),e._v(" 。  请注意，某些组（例如"),a("code",[e._v("(a*)")]),e._v(" ）与空字符串匹配。  当这样的组成功匹配输入中的空字符串时，此方法将返回空字符串。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("name")]),e._v(" - 此匹配器模式中的命名捕获组的名称")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("在上一个匹配期间由命名组捕获的（可能为空的）子 "),a("code",[e._v("序列，")]),e._v("如果组未能匹配输入的一部分， "),a("code",[e._v("则为null")])])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一个匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IllegalArgumentException")]),e._v("  - 如果在给定名称的模式中没有捕获组")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.7")])])]),e._v(" "),a("h2",{attrs:{id:"groupcount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#groupcount"}},[e._v("#")]),e._v(" groupCount")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int groupCount()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回此匹配器模式中捕获组的数量。")]),e._v(" "),a("p",[e._v("组零表示按照惯例的整个模式。 它不包括在这个计数。")]),e._v(" "),a("p",[e._v("任何小于或等于此方法返回值的非负整数将被保证为此匹配器的有效组索引。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Specified by:")]),e._v(" "),a("p",[a("code",[e._v("groupCount")]),e._v("中的  "),a("code",[e._v("MatchResult")])])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("在该匹配器模式中捕获组的数量")])])]),e._v(" "),a("h2",{attrs:{id:"matches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#matches"}},[e._v("#")]),e._v(" matches")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean matches()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("尝试将整个区域与模式进行匹配。")]),e._v(" "),a("p",[e._v("如果匹配成功可以通过"),a("code",[e._v("start，end")]),e._v("和"),a("code",[e._v("group")]),e._v("方法来获得，然后更多的信息。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[a("code",[e._v("true")]),e._v("如果，且仅当整个区域序列匹配该匹配器的模式")])])]),e._v(" "),a("h2",{attrs:{id:"find"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#find"}},[e._v("#")]),e._v(" find")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean find()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("尝试找到匹配模式的输入序列的下一个子序列。")]),e._v(" "),a("p",[e._v("该方法从该匹配器区域的开始处开始，或者如果该方法的先前调用成功，并且匹配器尚未被重置，则在与之前匹配不匹配的第一个字符处。")]),e._v(" "),a("p",[e._v("如果匹配成功可以通过"),a("code",[e._v("start，end")]),e._v("和"),a("code",[e._v("group")]),e._v("方法来获得，然后更多的信息。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[a("code",[e._v("true")]),e._v("如果并且仅当输入序列的子序列匹配该匹配器的模式")])])]),e._v(" "),a("h2",{attrs:{id:"find-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#find-2"}},[e._v("#")]),e._v(" find")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean find(int start)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("重新设置该匹配器，然后尝试从指定的索引开始找到匹配模式的输入序列的下一个子序列。")]),e._v(" "),a("p",[e._v("如果匹配成功可以通过"),a("code",[e._v("start，end")]),e._v("和"),a("code",[e._v("group")]),e._v("方法，以及随后的调用能够得到那么更多的信息"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#find--"}},[a("code",[e._v("find()")])]),e._v("方法将在不受此匹配匹配的第一个字符开始。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("start")]),e._v(" - 开始搜索匹配的索引")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[a("code",[e._v("true")]),e._v("如果并且仅当从给定索引开始的输入序列的子序列匹配该匹配器的模式")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IndexOutOfBoundsException")]),e._v("  - 如果start小于零，或者start大于输入序列的长度。")])])]),e._v(" "),a("h2",{attrs:{id:"lookingat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lookingat"}},[e._v("#")]),e._v(" lookingAt")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean lookingAt()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("尝试将输入序列从区域开头开始与模式相匹配。")]),e._v(" "),a("p",[e._v("像"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#matches--"}},[a("code",[e._v("matches")])]),e._v("方法一样，这种方法总是从该区域的开头开始;  不同于该方法，它不要求整个区域匹配。")],1),e._v(" "),a("p",[e._v("如果匹配成功可以通过"),a("code",[e._v("start，end")]),e._v("和"),a("code",[e._v("group")]),e._v("方法来获得，然后更多的信息。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[a("code",[e._v("true")]),e._v("如果，并且只有当输入序列的前缀匹配该匹配器的模式")])])]),e._v(" "),a("h2",{attrs:{id:"quotereplacement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quotereplacement"}},[e._v("#")]),e._v(" quoteReplacement")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public static String quoteReplacement(String s)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回面值替换"),a("code",[e._v("String")]),e._v("指定的"),a("code",[e._v("String")]),e._v(" 。  该方法产生一个"),a("code",[e._v("String")]),e._v(" ，可以在"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html"}},[a("code",[e._v("Matcher")])]),e._v("类的"),a("code",[e._v("appendReplacement")]),e._v("方法中作为文字替换"),a("code",[e._v("s")]),e._v("  。 该"),a("code",[e._v("String")]),e._v("产生将匹配的字符序列"),a("code",[e._v("s")]),e._v("作为文字序列处理。  斜杠（'''）和美元符号（'$'）将没有特殊意义。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("s")]),e._v(" - 要被字面化的字符串")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("一个文字字符串替换")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"appendreplacement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#appendreplacement"}},[e._v("#")]),e._v(" appendReplacement")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher appendReplacement(StringBuffer sb,\n                                 String replacement)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("实施非终端附加和替换步骤。")]),e._v(" "),a("p",[e._v("此方法执行以下操作：")]),e._v(" "),a("ol",[a("li",[e._v("它从输入序列读取字符，从附加位置开始，并将它们附加到给定的字符串缓冲区。  在读取上一个匹配之前的最后一个字符，即索引"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#start--"}},[e._v("号")]),e._v(" "),a("code",[e._v("start()")]),e._v(" "),a("code",[e._v("-")]),e._v(" "),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#start--"}},[e._v("1的")]),e._v(" "),a("code",[e._v("字符后")]),e._v(" "),a("code",[e._v("停止")]),e._v(" 。")],1),e._v(" "),a("li",[e._v("它将给定的替换字符串附加到字符串缓冲区。")]),e._v(" "),a("li",[e._v("它将该匹配器的追加位置设置为匹配的最后一个字符的索引，加上一个，即"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#end--"}},[a("code",[e._v("end()")])]),e._v("  。")],1)]),e._v(" "),a("p",[e._v("替换字符串可能包含对上一次匹配期间捕获的子序列的"),a("code",[e._v("引用")]),e._v(" ：每次出现的"),a("code",[e._v("${")]),e._v(" "),a("em",[e._v("名称")]),e._v(" "),a("code",[e._v("}")]),e._v("或"),a("code",[e._v("$")]),e._v(" "),a("em",[e._v("g")]),e._v("将分别由相应的"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#group-java.lang.String-"}},[a("code",[e._v("group(name)")])]),e._v("或"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#group-int-"}},[a("code",[e._v("group(g)")]),e._v("的")]),e._v("评估结果代替。  对于"),a("code",[e._v("*$克*")]),e._v(" ，所述"),a("code",[e._v("$")]),e._v("后的第一个数字始终被视为该组参考的一部分。  如果他们将组成法律团体参考，则将后续数字并入g。 只有数字“0”到“9”被认为是组参考的潜在组件。  例如，如果第二组匹配字符串"),a("code",[e._v('"foo"')]),e._v("  ，则传递替换字符串"),a("code",[e._v('"$2bar"')]),e._v("将导致"),a("code",[e._v('"foobar"')]),e._v("被附加到字符串缓冲器。 一个美元符号（  "),a("code",[e._v("$")]),e._v(" ）可以作为替代字符串中的文字包含在前面加反斜杠（ "),a("code",[e._v("\\$")]),e._v(" ）。")],1),e._v(" "),a("p",[e._v("请注意，替换字符串中的反斜杠（ "),a("code",[e._v("\\")]),e._v(" ）和美元符号（ "),a("code",[e._v("$")]),e._v("  ）可能会导致结果与被视为文字替换字符串时的结果不同。  如上所述，美元符号可被视为对捕获子序列的引用，反斜杠用于转义替换字符串中的文字字符。")]),e._v(" "),a("p",[e._v("该方法旨在与循环一起使用"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#appendTail-java.lang.StringBuffer-"}},[a("code",[e._v("appendTail")])]),e._v("和"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#find--"}},[a("code",[e._v("find")])]),e._v("方法。  例如，以下代码将"),a("code",[e._v("one dog two dogs in the yard")]),e._v("写入标准输出流：")],1),e._v(" "),a("blockquote",[a("p",[a("code",[e._v('Pattern p = Pattern.compile("cat"); Matcher m = p.matcher("one cat two cats in the yard"); StringBuffer sb = new StringBuffer(); while (m.find()) { m.appendReplacement(sb, "dog"); } m.appendTail(sb); System.out.println(sb.toString());')])])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("sb")]),e._v(" - 目标字符串缓冲区")]),e._v(" "),a("p",[a("code",[e._v("replacement")]),e._v(" - 替换字符串")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IllegalStateException")]),e._v("  - 如果尚未尝试匹配，或者前一匹配操作失败")]),e._v(" "),a("p",[a("code",[e._v("IllegalArgumentException")]),e._v("  - 如果替换字符串是指在模式中不存在的命名捕获组")]),e._v(" "),a("p",[a("code",[e._v("IndexOutOfBoundsException")]),e._v("  - 如果替换字符串是指在模式中不存在的捕获组")])])]),e._v(" "),a("h2",{attrs:{id:"appendtail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#appendtail"}},[e._v("#")]),e._v(" appendTail")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public StringBuffer appendTail(StringBuffer sb)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("实施终端附加和替换步骤。")]),e._v(" "),a("p",[e._v("此方法从输入序列读取字符，从追加位置开始，并将其附加到给定的字符串缓冲区。 旨在在"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-"}},[a("code",[e._v("appendReplacement")])]),e._v("方法的一个或多个调用之后调用，以便复制输入序列的其余部分。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("sb")]),e._v(" - 目标字符串缓冲区")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("目标字符串缓冲区")])])]),e._v(" "),a("h2",{attrs:{id:"replaceall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replaceall"}},[e._v("#")]),e._v(" replaceAll")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public String replaceAll(String replacement)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("将与模式匹配的输入序列的每个子序列替换为给定的替换字符串。")]),e._v(" "),a("p",[e._v("该方法首先重置此匹配器。 然后扫描输入序列，查找模式的匹配。  不属于任何匹配的字符将直接追加到结果字符串中; 每个匹配在替换字符串的结果中被替换。  替换字符串可能包含对"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-"}},[a("code",[e._v("appendReplacement")])]),e._v("方法中捕获的子序列的"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-"}},[e._v("引用")]),e._v("  。")],1),e._v(" "),a("p",[e._v("请注意，替换字符串中的反斜杠（ "),a("code",[e._v("\\")]),e._v(" ）和美元符号（ "),a("code",[e._v("$")]),e._v("  ）可能会导致结果与将其视为文字替换字符串时的结果不同。  如上所述，美元符号可被视为对捕获子序列的引用，反斜杠用于转义替换字符串中的文字字符。")]),e._v(" "),a("p",[e._v("给定正则表达式"),a("code",[e._v("a*b")]),e._v(" ，输入"),a("code",[e._v('"aabfooaabfooabfoob"')]),e._v("和替换字符串"),a("code",[e._v('"-"')]),e._v("  ，在该表达式的匹配器上调用此方法将产生字符串"),a("code",[e._v('"-foo-foo-foo-"')]),e._v(" 。")]),e._v(" "),a("p",[e._v("调用此方法会更改此匹配器的状态。 如果匹配器要用于进一步的匹配操作，那么应该首先被重置。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("replacement")]),e._v(" - 替换字符串")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("通过用替换字符串替换每个匹配子序列构造的字符串，根据需要代替捕获的子序列")])])]),e._v(" "),a("h2",{attrs:{id:"replacefirst"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replacefirst"}},[e._v("#")]),e._v(" replaceFirst")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public String replaceFirst(String replacement)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("将与模式匹配的输入序列的第一个子序列替换为给定的替换字符串。")]),e._v(" "),a("p",[e._v("该方法首先重置此匹配器。 然后扫描输入序列寻找模式的匹配。  不属于匹配的字符将直接附加到结果字符串中; 匹配在结果中被替换字符串替换。  替换字符串可能包含对"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-"}},[a("code",[e._v("appendReplacement")])]),e._v("方法中捕获的子序列的"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-"}},[e._v("引用")]),e._v("  。")],1),e._v(" "),a("p",[e._v("请注意，替换字符串中的反斜杠（ "),a("code",[e._v("\\")]),e._v(" ）和美元符号（ "),a("code",[e._v("$")]),e._v("  ）可能会导致结果与被视为文字替换字符串时的结果不同。  如上所述，美元符号可被视为对捕获子序列的引用，反斜杠用于转义替换字符串中的文字字符。")]),e._v(" "),a("p",[e._v("给定正则表达式"),a("code",[e._v("dog")]),e._v(" ，输入"),a("code",[e._v('"zzzdogzzzdogzzz"')]),e._v("和替换字符串"),a("code",[e._v('"cat"')]),e._v("  ，在该表达式的匹配器上调用此方法将产生字符串"),a("code",[e._v('"zzzcatzzzdogzzz"')]),e._v(" 。")]),e._v(" "),a("p",[e._v("调用此方法会更改此匹配器的状态。 如果匹配器要用于进一步的匹配操作，那么应该首先被重置。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("replacement")]),e._v(" - 替换字符串")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("通过用替换字符串替换第一匹配子序列构造的字符串，根据需要代替捕获的子序列")])])]),e._v(" "),a("h2",{attrs:{id:"region"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#region"}},[e._v("#")]),e._v(" region")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher region(int start,\n                      int end)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("设置该匹配器区域的限制。该区域是将被搜索以找到匹配的输入序列的一部分。调用此方法重置匹配器，然后设置区域由指定的索引处开始"),a("code",[e._v("start")]),e._v("由指定的索引在参数和结束"),a("code",[e._v("end")]),e._v("参数。")]),e._v(" "),a("p",[e._v("取决于所使用的"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useTransparentBounds-boolean-"}},[e._v("透明度")]),e._v("和锚定（参见"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useTransparentBounds-boolean-"}},[a("code",[e._v("useTransparentBounds")])]),e._v("和"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useAnchoringBounds-boolean-"}},[a("code",[e._v("useAnchoringBounds")])]),e._v("  ），某些构造例如锚点可能在该区域的边界处或周围具有不同的表现。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("start")]),e._v(" - 开始搜索的索引（含）")]),e._v(" "),a("p",[a("code",[e._v("end")]),e._v(" - 结束搜索的索引（独占）")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])]),e._v(" "),a("li",[a("p",[e._v("异常")]),e._v(" "),a("p",[a("code",[e._v("IndexOutOfBoundsException")]),e._v("  - 如果start或end小于零，如果start大于输入序列的长度，如果end大于输入序列的长度，或者start大于end。")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"regionstart"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regionstart"}},[e._v("#")]),e._v(" regionStart")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int regionStart()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("报告该匹配器区域的开始索引。 该匹配器进行的搜索仅限于发现"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#regionStart--"}},[a("code",[e._v("regionStart")])]),e._v("  （含）和"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#regionEnd--"}},[a("code",[e._v("regionEnd")])]),e._v("  （排他性）中的匹配项。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配者地区的起点")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"regionend"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regionend"}},[e._v("#")]),e._v(" regionEnd")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public int regionEnd()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("报告该匹配器区域的最终索引（排他）。 该匹配器进行的搜索仅限于在"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#regionStart--"}},[a("code",[e._v("regionStart")])]),e._v("  （含）和"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#regionEnd--"}},[a("code",[e._v("regionEnd")])]),e._v("  （独家）中找到匹配项。")],1),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("该匹配器区域的终点")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"hastransparentbounds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hastransparentbounds"}},[e._v("#")]),e._v(" hasTransparentBounds")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean hasTransparentBounds()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("查询此匹配器的区域边界的透明度。")]),e._v(" "),a("p",[e._v("如果此匹配器使用"),a("em",[e._v("透明")]),e._v("边界"),a("code",[e._v("false（")]),e._v("如果它使用"),a("em",[e._v("不透明")]),e._v("边界），则此方法返回"),a("code",[e._v("true")]),e._v("  。")]),e._v(" "),a("p",[e._v("有关"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useTransparentBounds-boolean-"}},[e._v("透明")]),e._v("和不透明边界的说明，请参阅"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useTransparentBounds-boolean-"}},[a("code",[e._v("useTransparentBounds")])]),e._v("  。")],1),e._v(" "),a("p",[e._v("默认情况下，匹配器使用不透明区域边界。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[a("code",[e._v("true")]),e._v(" iff这个匹配器是否使用透明边界， "),a("code",[e._v("否则为")]),e._v(" false。")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])]),e._v(" "),a("li",[a("p",[e._v("另请参见：")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useTransparentBounds-boolean-"}},[a("code",[e._v("useTransparentBounds(boolean)")])])],1)])]),e._v(" "),a("h2",{attrs:{id:"usetransparentbounds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usetransparentbounds"}},[e._v("#")]),e._v(" useTransparentBounds")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher useTransparentBounds(boolean b)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("设置此匹配器的区域边界的透明度。")]),e._v(" "),a("p",[e._v("使用参数"),a("code",[e._v("true")]),e._v("调用此方法将设置此匹配器以使用"),a("em",[e._v("透明")]),e._v("边界。  如果布尔参数为"),a("code",[e._v("false")]),e._v(" ，则将使用"),a("em",[e._v("不透明")]),e._v("边界。")]),e._v(" "),a("p",[e._v("使用透明边界，该匹配器区域的边界对于lookahead，lookbehind和边界匹配结构是透明的。  那些结构可以超越该地区的边界，看看匹配是否合适。")]),e._v(" "),a("p",[e._v("使用不透明边界，该匹配器区域的边界对于可能尝试超越它们的lookahead，lookbehind和边界匹配结构是不透明的。  这些构造不能超越边界，因此它们将无法匹配该区域之外的任何内容。")]),e._v(" "),a("p",[e._v("默认情况下，匹配器使用不透明边界。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("b")]),e._v(" - 指示是否使用不透明或透明区域的布尔值")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])]),e._v(" "),a("li",[a("p",[e._v("另请参见：")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#hasTransparentBounds--"}},[a("code",[e._v("hasTransparentBounds()")])])],1)])]),e._v(" "),a("h2",{attrs:{id:"hasanchoringbounds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hasanchoringbounds"}},[e._v("#")]),e._v(" hasAnchoringBounds")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean hasAnchoringBounds()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("查询该匹配器的区域边界的锚定。")]),e._v(" "),a("p",[e._v("如果该匹配器使用"),a("em",[e._v("锚定")]),e._v("边界，则此方法返回"),a("code",[e._v("true")]),e._v(" ， "),a("code",[e._v("否则为")]),e._v(" false。")]),e._v(" "),a("p",[e._v("有关"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useAnchoringBounds-boolean-"}},[e._v("锚")]),e._v("定界限的说明，请参阅"),a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useAnchoringBounds-boolean-"}},[a("code",[e._v("useAnchoringBounds")])]),e._v("  。")],1),e._v(" "),a("p",[e._v("默认情况下，匹配器使用锚定区域边界。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[a("code",[e._v("true")]),e._v("如果这个匹配器正在使用锚定边界， "),a("code",[e._v("false")]),e._v("否则。")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])]),e._v(" "),a("li",[a("p",[e._v("另请参见：")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#useAnchoringBounds-boolean-"}},[a("code",[e._v("useAnchoringBounds(boolean)")])])],1)])]),e._v(" "),a("h2",{attrs:{id:"useanchoringbounds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useanchoringbounds"}},[e._v("#")]),e._v(" useAnchoringBounds")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public Matcher useAnchoringBounds(boolean b)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("设置该匹配器的区域边界的锚定。")]),e._v(" "),a("p",[e._v("使用参数"),a("code",[e._v("true")]),e._v("调用此方法将设置此匹配器以使用"),a("em",[e._v("锚定")]),e._v("边界。  如果布尔参数为"),a("code",[e._v("false")]),e._v(" ，则将使用"),a("em",[e._v("非锚定")]),e._v("边界。")]),e._v(" "),a("p",[e._v("使用锚定边界，该匹配器区域的边界匹配诸如^和$之类的锚点。")]),e._v(" "),a("p",[e._v("没有锚定边界，该匹配器区域的边界将不匹配诸如^和$之类的锚点。")]),e._v(" "),a("p",[e._v("默认情况下，匹配器使用锚定区域边界。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("参数")]),e._v(" "),a("p",[a("code",[e._v("b")]),e._v(" - 一个布尔值，表示是否使用固定边界。")])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("这个匹配器")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])]),e._v(" "),a("li",[a("p",[e._v("另请参见：")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/java/util/regex/Matcher.html#hasAnchoringBounds--"}},[a("code",[e._v("hasAnchoringBounds()")])])],1)])]),e._v(" "),a("h2",{attrs:{id:"tostring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[e._v("#")]),e._v(" toString")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public String toString()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("返回此匹配器的字符串表示形式。  Matcher的字符串表示"),a("code",[e._v("Matcher")]),e._v("包含可能对调试有用的信息。  确切的格式是未指定的。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("重写：")]),e._v(" "),a("p",[a("code",[e._v("toString")]),e._v("在 "),a("code",[e._v("Object")])])]),e._v(" "),a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("该匹配器的字符串表示形式")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"hitend"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hitend"}},[e._v("#")]),e._v(" hitEnd")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean hitEnd()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("如果在匹配器执行的最后一次匹配操作中输入的结尾被搜索引擎命中，则返回true。")]),e._v(" "),a("p",[e._v("当此方法返回true时，可能更多的输入会改变上一次搜索的结果。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("如果输入的结尾在最后一场比赛中被击中，则为true; 否则为假")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])]),e._v(" "),a("h2",{attrs:{id:"requireend"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requireend"}},[e._v("#")]),e._v(" requireEnd")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public boolean requireEnd()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("如果更多输入可以将正匹配更改为否定，则返回true。")]),e._v(" "),a("p",[e._v("如果此方法返回true，并且找到匹配，则更多的输入可能会导致匹配丢失。  如果此方法返回false并找到匹配，则更多输入可能会更改匹配，但匹配不会丢失。  如果没有找到匹配项，那么requireEnd就没有意义了。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("结果")]),e._v(" "),a("p",[e._v("如果更多的输入可以将正匹配改变为负值，则为true。")])]),e._v(" "),a("li",[a("p",[e._v("从以下版本开始：")]),e._v(" "),a("p",[e._v("1.5")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);