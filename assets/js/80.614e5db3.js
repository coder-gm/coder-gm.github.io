(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{699:function(t,e,a){"use strict";a.r(e);var v=a(33),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"作用与解释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用与解释"}},[t._v("#")]),t._v(" 作用与解释")]),t._v(" "),a("p",[t._v("java.util.regex.Matcher类的实例的作用是增加表达式匹配字符串的权利，让正则表达式更自由的匹配字符串。比如调用Matcher实例的方法，正则表达式可以匹配整个字符串、可以匹配字符串最前端的子串、最后段的子串、或者任意位置的子串等等。")]),t._v(" "),a("h1",{attrs:{id:"方法详细信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法详细信息"}},[t._v("#")]),t._v(" 方法详细信息")]),t._v(" "),a("h2",{attrs:{id:"compile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compile"}},[t._v("#")]),t._v(" compile")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static Pattern compile(String regex)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("将给定的正则表达式编译为模式。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("regex")]),t._v(" - 要编译的表达式")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("给定的正则表达式编译成一个模式")])]),t._v(" "),a("li",[a("p",[t._v("异常")]),t._v(" "),a("p",[a("code",[t._v("PatternSyntaxException")]),t._v("  - 如果表达式的语法无效")])])]),t._v(" "),a("h2",{attrs:{id:"compile-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compile-2"}},[t._v("#")]),t._v(" compile")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static Pattern compile(String regex,int flags)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("将给定的正则表达式编译为带有给定标志的模式。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("regex")]),t._v(" - 要编译的表达式")]),t._v(" "),a("p",[a("code",[t._v("flags")]),t._v(" -匹配标志，一个位掩码，可能包括 "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#CASE_INSENSITIVE"}},[a("code",[t._v("CASE_INSENSITIVE")])]),t._v("  ， "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#MULTILINE"}},[a("code",[t._v("MULTILINE")])]),t._v("  ， "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#DOTALL"}},[a("code",[t._v("DOTALL")])]),t._v("  ， "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#UNICODE_CASE"}},[a("code",[t._v("UNICODE_CASE")])]),t._v("  ， "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#CANON_EQ"}},[a("code",[t._v("CANON_EQ")])]),t._v("  ， "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#UNIX_LINES"}},[a("code",[t._v("UNIX_LINES")])]),t._v("  ， "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#LITERAL"}},[a("code",[t._v("LITERAL")])]),t._v(" ，  "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS"}},[a("code",[t._v("UNICODE_CHARACTER_CLASS")])]),t._v("和  "),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#COMMENTS"}},[a("code",[t._v("COMMENTS")])])],1)]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("给定的正则表达式编译成带有给定标志的模式")])]),t._v(" "),a("li",[a("p",[t._v("异常")]),t._v(" "),a("p",[a("code",[t._v("IllegalArgumentException")]),t._v("  - 如果在 "),a("code",[t._v("flags")]),t._v("中设置了与定义的匹配标志相对应的位之外的位值")]),t._v(" "),a("p",[a("code",[t._v("PatternSyntaxException")]),t._v("  - 如果表达式的语法无效")])])]),t._v(" "),a("h2",{attrs:{id:"pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pattern"}},[t._v("#")]),t._v(" pattern")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public String pattern()\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("返回编译此模式的正则表达式。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("这种模式的来源")])])]),t._v(" "),a("h2",{attrs:{id:"tostring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[t._v("#")]),t._v(" toString")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public String toString()\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("返回此模式的字符串表示形式。 这是编译此模式的正则表达式。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("重写：")]),t._v(" "),a("p",[a("code",[t._v("toString")]),t._v("在类 "),a("code",[t._v("Object")])])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("该模式的字符串表示形式")])]),t._v(" "),a("li",[a("p",[t._v("从以下版本开始：")]),t._v(" "),a("p",[t._v("1.5")])])]),t._v(" "),a("h2",{attrs:{id:"matcher"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#matcher"}},[t._v("#")]),t._v(" matcher")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public Matcher matcher(CharSequence input)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("创建一个匹配器，匹配给定的输入与此模式。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("input")]),t._v(" - 要匹配的字符序列")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("这种模式的新匹配器")])])]),t._v(" "),a("h2",{attrs:{id:"flags"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flags"}},[t._v("#")]),t._v(" flags")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public int flags()\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("返回此模式的匹配标志。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("编译此模式时指定的匹配标志")])])]),t._v(" "),a("h2",{attrs:{id:"matches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#matches"}},[t._v("#")]),t._v(" matches")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static boolean matches(String regex,\n                              CharSequence input)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("编译给定的正则表达式，并尝试匹配给定的输入。")]),t._v(" "),a("p",[t._v("调用这种方便的方式的形式")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("Pattern.matches(regex, input);")])])]),t._v(" "),a("p",[t._v("表现方式与表达式完全相同")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("Pattern.compile(regex).matcher(input).matches()")])])]),t._v(" "),a("p",[t._v("如果一个模式多次被使用，编译一次并重用它将比每次调用此方法更有效。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("regex")]),t._v(" - 要编译的表达式")]),t._v(" "),a("p",[a("code",[t._v("input")]),t._v(" - 要匹配的字符序列")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("正则表达式是否匹配输入")])]),t._v(" "),a("li",[a("p",[t._v("异常")]),t._v(" "),a("p",[a("code",[t._v("PatternSyntaxException")]),t._v("  - 如果表达式的语法无效")])])]),t._v(" "),a("h2",{attrs:{id:"split"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#split"}},[t._v("#")]),t._v(" split")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public String[] split(CharSequence input,\n                      int limit)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("将给定的输入序列分成这个模式的匹配。")]),t._v(" "),a("p",[t._v("由此方法返回的数组包含输入序列的每个子字符串，由与此模式匹配的另一个子序列终止，或者由输入序列的末尾终止。  数组中的子字符串按照它们在输入中出现的顺序。  如果该模式与输入的任何子序列不匹配，则生成的数组只有一个元素，即字符串形式的输入序列。")]),t._v(" "),a("p",[t._v("当在输入序列的开始处存在正宽度匹配时，在结果数组的开始处包含一个空的前导子串。  开始时的零宽度匹配不会产生这样的空的前导子串。")]),t._v(" "),a("p",[a("code",[t._v("limit")]),t._v("参数控制应用模式的次数，因此影响生成的数组的长度。  如果极限"),a("em",[t._v("n")]),t._v("大于0，则模式最多应用"),a("em",[t._v("n")]),t._v(" -1次，数组的长度不大于"),a("em",[t._v("n")]),t._v("  ，数组的最后一个条目将包含超出最后一个匹配分隔符的所有输入。  如果"),a("em",[t._v("n")]),t._v("是非正的，那么模式将被应用到尽可能多的次数，并且数组可以有任何长度。  如果"),a("em",[t._v("n")]),t._v("为0，则模式将被应用尽可能多次，数组可以有任何长度，并且尾随的空字符串将被丢弃。")]),t._v(" "),a("p",[t._v("例如，输入"),a("code",[t._v('"boo:and:foo"')]),t._v("通过以下参数产生以下结果：")]),t._v(" "),a("blockquote",[a("p",[a("em",[t._v("Regex")]),t._v(" "),a("em",[t._v("Limit")]),t._v(" "),a("em",[t._v("Result")]),t._v("   : 2 "),a("code",[t._v('{ "boo", "and:foo" }')]),t._v(" : 5 "),a("code",[t._v('{ "boo", "and", "foo" }')]),t._v(" : -2 "),a("code",[t._v('{ "boo", "and", "foo" }')]),t._v(" o 5 "),a("code",[t._v('{ "b", "", ":and:f", "", "" }')]),t._v(" o -2 "),a("code",[t._v('{ "b", "", ":and:f", "", "" }')]),t._v(" o 0 "),a("code",[t._v('{ "b", "", ":and:f" }')])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("input")]),t._v(" - 要分割的字符序列")]),t._v(" "),a("p",[a("code",[t._v("limit")]),t._v(" - 结果阈值，如上所述")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("通过将输入围绕该模式的匹配分割来计算的字符串数组")])])]),t._v(" "),a("h2",{attrs:{id:"split-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#split-2"}},[t._v("#")]),t._v(" split")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public String[] split(CharSequence input)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("将给定的输入序列分成这个模式的匹配。")]),t._v(" "),a("p",[t._v("该方法的工作原理是通过调用具有给定输入序列和限制参数为零的双参数"),a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-"}},[a("code",[t._v("split")])]),t._v("方法。  因此，尾随的空字符串不会包含在结果数组中。")],1),t._v(" "),a("p",[t._v("输入"),a("code",[t._v('"boo:and:foo"')]),t._v(" ，例如，使用以下表达式得到以下结果：")]),t._v(" "),a("blockquote",[a("p",[a("em",[t._v("Regex")]),t._v(" "),a("em",[t._v("Result")]),t._v(" : "),a("code",[t._v('{ "boo", "and", "foo" }')]),t._v(" o "),a("code",[t._v('{ "b", "", ":and:f" }')])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("input")]),t._v(" - 要分割的字符序列")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("通过将输入围绕该模式的匹配分割来计算的字符串数组")])])]),t._v(" "),a("h2",{attrs:{id:"quote"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quote"}},[t._v("#")]),t._v(" quote")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static String quote(String s)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("返回指定的"),a("code",[t._v("String")]),t._v("的文字模式"),a("code",[t._v("String")]),t._v(" 。")]),t._v(" "),a("p",[t._v("该方法产生一个"),a("code",[t._v("String")]),t._v(" ，可用于创建一个"),a("code",[t._v("Pattern")]),t._v("  ，它将匹配字符串"),a("code",[t._v("s")]),t._v(" ，就像它是一个文字模式。")]),t._v(" "),a("p",[t._v("输入序列中的元字符或转义序列将没有特殊的含义。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("s")]),t._v(" - 要被字面化的字符串")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("一个文字字符串替换")])]),t._v(" "),a("li",[a("p",[t._v("从以下版本开始：")]),t._v(" "),a("p",[t._v("1.5")])])]),t._v(" "),a("h2",{attrs:{id:"aspredicate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aspredicate"}},[t._v("#")]),t._v(" asPredicate")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public Predicate<String> asPredicate()\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("创建可用于匹配字符串的谓词。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("可用于匹配字符串的谓词")])]),t._v(" "),a("li",[a("p",[t._v("从以下版本开始：")]),t._v(" "),a("p",[t._v("1.8")])])]),t._v(" "),a("h2",{attrs:{id:"splitasstream"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#splitasstream"}},[t._v("#")]),t._v(" splitAsStream")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public Stream<String> splitAsStream(CharSequence input)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("根据给定的输入序列创建一个流，该流与该模式匹配。")]),t._v(" "),a("p",[t._v("由此方法返回的流包含输入序列的每个子字符串，由与该模式匹配的另一个子序列终止，或者由输入序列的结尾终止。  流中的子串按照它们在输入中出现的顺序。 尾随的空字符串将被丢弃，不会在流中遇到。")]),t._v(" "),a("p",[t._v("如果该模式与输入的任何子序列不匹配，则生成的流只有一个元素，即字符串形式的输入序列。")]),t._v(" "),a("p",[t._v("当在输入序列的开始处存在正宽度匹配时，在流的开始处包含空的前导子串。  开始时的零宽度匹配不会产生这样的空的前导子串。")]),t._v(" "),a("p",[t._v("如果输入序列是可变的，则在执行终端流操作期间它必须保持不变。 否则，终端流操作的结果未定义。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参数")]),t._v(" "),a("p",[a("code",[t._v("input")]),t._v(" - 要分割的字符序列")])]),t._v(" "),a("li",[a("p",[t._v("结果")]),t._v(" "),a("p",[t._v("通过将输入分割为该模式的匹配计算的字符串流")])]),t._v(" "),a("li",[a("p",[t._v("从以下版本开始：")]),t._v(" "),a("p",[t._v("1.8")])]),t._v(" "),a("li",[a("p",[t._v("另请参见：")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/java/util/regex/Pattern.html#split-java.lang.CharSequence-"}},[a("code",[t._v("split(CharSequence)")])])],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);