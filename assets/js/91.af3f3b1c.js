(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{722:function(_,v,s){"use strict";s.r(v);var t=s(33),e=Object(t.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"第1章-innodb数据存储结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第1章-innodb数据存储结构"}},[_._v("#")]),_._v(" 第1章 InnoDB数据存储结构")]),_._v(" "),s("h2",{attrs:{id:"_1-数据库的存储结构-页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据库的存储结构-页"}},[_._v("#")]),_._v(" 1. 数据库的存储结构：页")]),_._v(" "),s("p",[_._v("索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的"),s("code",[_._v("存储引擎")]),_._v("负责对表中数据的读取和写入工作。不同存储引擎中"),s("code",[_._v("存放的格式")]),_._v("一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。")]),_._v(" "),s("p",[_._v("由于"),s("code",[_._v("InnoDB")]),_._v("是MySQL的"),s("code",[_._v("默认存储引擎")]),_._v("，所以本章剖析InooDB存储引擎的数据存储结构。")]),_._v(" "),s("h3",{attrs:{id:"_1-1-磁盘与内存交互基本单位-页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-磁盘与内存交互基本单位-页"}},[_._v("#")]),_._v(" 1.1 磁盘与内存交互基本单位：页")]),_._v(" "),s("p",[_._v("InnoDB将数据划分为若干个页，InnoDB中页的大小默认为"),s("code",[_._v("16KB")]),_._v("。")]),_._v(" "),s("p",[_._v("以"),s("code",[_._v("页")]),_._v("作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。")]),_._v(" "),s("blockquote",[s("p",[_._v("记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。")])]),_._v(" "),s("h3",{attrs:{id:"_1-2-页结构概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-页结构概述"}},[_._v("#")]),_._v(" 1.2 页结构概述")]),_._v(" "),s("p",[_._v("页a、页b、页c...页n这些页可以"),s("code",[_._v("不在物理结构上相连")]),_._v("，只要通过"),s("code",[_._v("双向链表")]),_._v("相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个"),s("code",[_._v("单向链表")]),_._v("，每个数据页都会为存储在它里边的记录生成一个"),s("code",[_._v("页目录")]),_._v("，在通过主键查找某条记录的时候可以在页目录中"),s("code",[_._v("使用二分法")]),_._v("快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。")]),_._v(" "),s("h3",{attrs:{id:"_1-3-页的上层结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-页的上层结构"}},[_._v("#")]),_._v(" 1.3 页的上层结构")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301838071.png",alt:"image-20220330183814954"}})]),_._v(" "),s("p",[_._v("区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配"),s("code",[_._v("64个连续的页")]),_._v("。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB="),s("code",[_._v("1MB")]),_._v("。")]),_._v(" "),s("p",[_._v("段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。"),s("code",[_._v("段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。")]),_._v("当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。")]),_._v(" "),s("p",[_._v("表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为"),s("code",[_._v("系统表空间")]),_._v("、"),s("code",[_._v("用户表空间")]),_._v("、"),s("code",[_._v("撤销表空间")]),_._v("、"),s("code",[_._v("临时表空间")]),_._v("等。")]),_._v(" "),s("h2",{attrs:{id:"_2-页的内部结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-页的内部结构"}},[_._v("#")]),_._v(" 2. 页的内部结构")]),_._v(" "),s("h3",{attrs:{id:"_2-1-第1部分-文件头部和文件尾部"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-第1部分-文件头部和文件尾部"}},[_._v("#")]),_._v(" 2.1 第1部分：文件头部和文件尾部")]),_._v(" "),s("h4",{attrs:{id:"_2-1-1-file-header-文件头部-38字节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-file-header-文件头部-38字节"}},[_._v("#")]),_._v(" 2.1.1 File Header（文件头部）（38字节）")]),_._v(" "),s("p",[s("strong",[_._v("作用")]),_._v("：\n描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）")]),_._v(" "),s("p",[s("strong",[_._v("大小")]),_._v("：38字节")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("名称")]),_._v(" "),s("th",[_._v("占用空间大小")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[s("code",[_._v("FIL_PAGE_SPACE_OR_CHKSUM")])]),_._v(" "),s("td",[s("code",[_._v("4")]),_._v("字节")]),_._v(" "),s("td",[_._v("页的校验和（checksum值）")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_OFFSET")])]),_._v(" "),s("td",[s("code",[_._v("4")]),_._v("字节")]),_._v(" "),s("td",[_._v("页号")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_PREV")])]),_._v(" "),s("td",[s("code",[_._v("4")]),_._v("字节")]),_._v(" "),s("td",[_._v("上一个页的页号")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_NEXT")])]),_._v(" "),s("td",[s("code",[_._v("4")]),_._v("字节")]),_._v(" "),s("td",[_._v("下一个页的页号")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_LSN")]),_._v(" "),s("td",[s("code",[_._v("8")]),_._v("字节")]),_._v(" "),s("td",[_._v("页面被最后修改时对应的日志序列位置")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_TYPE")])]),_._v(" "),s("td",[s("code",[_._v("2")]),_._v("字节")]),_._v(" "),s("td",[_._v("该页的类型")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_FILE_FLUSH_LSN")]),_._v(" "),s("td",[s("code",[_._v("8")]),_._v("字节")]),_._v(" "),s("td",[_._v("仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID")])]),_._v(" "),s("td",[s("code",[_._v("4")]),_._v("字节")]),_._v(" "),s("td",[_._v("页属于哪个表空间")])])])]),_._v(" "),s("ul",[s("li",[s("code",[_._v("FIL_PAGE_OFFSET（4字节）")]),_._v("：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。")]),_._v(" "),s("li",[s("code",[_._v("FIL_PAGE_TYPE（2字节）")]),_._v("：这个代表当前页的类型。")])]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("类型名称")]),_._v(" "),s("th",[_._v("十六进制")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("FIL_PAGE_TYPE_ALLOCATED")]),_._v(" "),s("td",[_._v("0x0000")]),_._v(" "),s("td",[_._v("最新分配，还没有使用")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_UNDO_LOG")])]),_._v(" "),s("td",[_._v("0x0002")]),_._v(" "),s("td",[_._v("Undo日志页")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_INODE")]),_._v(" "),s("td",[_._v("0x0003")]),_._v(" "),s("td",[_._v("段信息节点")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_IBUF_FREE_LIST")]),_._v(" "),s("td",[_._v("0x0004")]),_._v(" "),s("td",[_._v("Insert Buffer空闲列表")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_IBUF_BITMAP")]),_._v(" "),s("td",[_._v("0x0005")]),_._v(" "),s("td",[_._v("Insert Buffer位图")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_TYPE_SYS")])]),_._v(" "),s("td",[_._v("0x0006")]),_._v(" "),s("td",[_._v("系统页")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_TYPE_TRX_SYS")]),_._v(" "),s("td",[_._v("0x0007")]),_._v(" "),s("td",[_._v("事务系统数据")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_TYPE_FSP_HDR")]),_._v(" "),s("td",[_._v("0x0008")]),_._v(" "),s("td",[_._v("表空间头部信息")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_TYPE_XDES")]),_._v(" "),s("td",[_._v("0x0009")]),_._v(" "),s("td",[_._v("扩展描述页")])]),_._v(" "),s("tr",[s("td",[_._v("FIL_PAGE_TYPE_BLOB")]),_._v(" "),s("td",[_._v("0x000A")]),_._v(" "),s("td",[_._v("溢出页")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("FIL_PAGE_INDEX")])]),_._v(" "),s("td",[_._v("0x45BF")]),_._v(" "),s("td",[_._v("索引页，也就是我们所说的"),s("code",[_._v("数据页")])])])])]),_._v(" "),s("ul",[s("li",[s("code",[_._v("FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）")]),_._v("：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间"),s("strong",[_._v("不需要是物理上的连续，而是逻辑上的连续。")])]),_._v(" "),s("li",[s("code",[_._v("FIL_PAGE_SPACE_OR_CHKSUM（4字节）")]),_._v("：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM")])]),_._v(" "),s("p",[s("strong",[_._v("作用：")])]),_._v(" "),s("p",[_._v("InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么"),s("code",[_._v("在修改后的某个时间需要把数据同步到磁盘中。")]),_._v("但是在同步了一半的时候断电了，造成了该页传输的不完整。")]),_._v(" "),s("p",[_._v("为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。")]),_._v(" "),s("ul",[s("li",[s("code",[_._v("FIL_PAGE_LSN（8字节）")]),_._v("：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）")])]),_._v(" "),s("h4",{attrs:{id:"_2-1-2-file-trailer-文件尾部-8字节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-file-trailer-文件尾部-8字节"}},[_._v("#")]),_._v(" 2.1.2 File Trailer（文件尾部）（8字节）")]),_._v(" "),s("ul",[s("li",[_._v("前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。")]),_._v(" "),s("li",[_._v("后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。")])]),_._v(" "),s("h3",{attrs:{id:"_2-2-第2部分-空闲空间、用户记录和最小最大记录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-第2部分-空闲空间、用户记录和最小最大记录"}},[_._v("#")]),_._v(" 2.2 第2部分：空闲空间、用户记录和最小最大记录")]),_._v(" "),s("h4",{attrs:{id:"_2-2-1-free-space-空闲空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-free-space-空闲空间"}},[_._v("#")]),_._v(" 2.2.1 Free Space (空闲空间)")]),_._v(" "),s("p",[_._v("我们自己存储的记录会按照指定的"),s("code",[_._v("行格式")]),_._v("存储到"),s("code",[_._v("User Records")]),_._v("部分。但是在一开始生成页的时候，其实并没有User Records这个部分，"),s("code",[_._v("每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分")]),_._v("，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去"),s("code",[_._v("申请新的页")]),_._v("了。")]),_._v(" "),s("h4",{attrs:{id:"_2-2-2-user-records-用户记录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-user-records-用户记录"}},[_._v("#")]),_._v(" 2.2.2 User Records (用户记录)")]),_._v(" "),s("p",[_._v("User Records中的这些记录按照"),s("code",[_._v("指定的行格式")]),_._v("一条一条摆在User Records部分，相互之间形成"),s("code",[_._v("单链表")]),_._v("。")]),_._v(" "),s("h4",{attrs:{id:"_2-2-3-infimum-supremum-最小最大记录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-infimum-supremum-最小最大记录"}},[_._v("#")]),_._v(" 2.2.3 Infimum + Supremum（最小最大记录）")]),_._v(" "),s("p",[s("strong",[_._v("记录可以比较大小吗")]),_._v("？\n是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是"),s("code",[_._v("比较主键")]),_._v("的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。")]),_._v(" "),s("p",[_._v("InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301913664.png",alt:"image-20220330191335574"}})]),_._v(" "),s("p",[_._v("这两条记录"),s("code",[_._v("不是我们自己定义的记录")]),_._v("，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301914167.png",alt:"image-20220330191446070"}})]),_._v(" "),s("h3",{attrs:{id:"_2-3-第3部分-页目录和页面头部"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-第3部分-页目录和页面头部"}},[_._v("#")]),_._v(" 2.3 第3部分：页目录和页面头部")]),_._v(" "),s("h4",{attrs:{id:"_2-3-1-page-directory-页目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-page-directory-页目录"}},[_._v("#")]),_._v(" 2.3.1 Page Directory（页目录）")]),_._v(" "),s("p",[s("strong",[_._v("为什么需要页目录")]),_._v("？\n在页中，记录是以"),s("code",[_._v("单向链表")]),_._v("的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是"),s("code",[_._v("检索效率不高")]),_._v("，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，"),s("code",[_._v("专门给记录做一个目录")]),_._v("，通过"),s("code",[_._v("二分查找法")]),_._v("的方式进行检索，提升效率。")]),_._v(" "),s("p",[s("strong",[_._v("页目录，二分法查找")])]),_._v(" "),s("ol",[s("li",[_._v("将所有的记录"),s("code",[_._v("分成几个组")]),_._v("，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。")]),_._v(" "),s("li",[_._v("第 1 组，也就是最小记录所在的分组只有 1 个记录；\n最后一组，就是最大记录所在的分组，会有 1-8 条记录；\n其余的组记录数量在 4-8 条之间。\n这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会"),s("code",[_._v("尽量平分")]),_._v("。")]),_._v(" "),s("li",[_._v("在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。")]),_._v(" "),s("li",[s("code",[_._v("页目录用来存储每组最后一条记录的地址偏移量")]),_._v("，这些地址偏移量会按照"),s("code",[_._v("先后顺序存储")]),_._v("起来，每组的地址偏移量也被称之为"),s("code",[_._v("槽（slot）")]),_._v("，每个槽相当于指针指向了不同组的最后一个记录。")])]),_._v(" "),s("p",[s("strong",[_._v("举例：")])]),_._v(" "),s("p",[_._v("现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301921631.png",alt:"image-20220330192130497"}})]),_._v(" "),s("p",[_._v("从这个图中我们需要注意这么几点：")]),_._v(" "),s("ul",[s("li",[_._v("现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。")]),_._v(" "),s("li",[_._v("注意最小和最大记录的头信息中的n_owned属性\n"),s("ul",[s("li",[_._v("最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。")]),_._v(" "),s("li",[_._v("最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。")])])])]),_._v(" "),s("p",[_._v("用箭头指向的方式替代数字，这样更易于我们理解，修改后如下")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301924874.png",alt:"image-20220330192413776"}})]),_._v(" "),s("p",[s("strong",[_._v("为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？")])]),_._v(" "),s("p",[_._v("InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1~8条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。")]),_._v(" "),s("p",[_._v("分组是按照下边的步骤进行的：")]),_._v(" "),s("ul",[s("li",[_._v("初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。")]),_._v(" "),s("li",[_._v("之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。")]),_._v(" "),s("li",[_._v("在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。")])]),_._v(" "),s("h4",{attrs:{id:"_2-3-2-page-header-页面头部"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-page-header-页面头部"}},[_._v("#")]),_._v(" 2.3.2 Page Header（页面头部）")]),_._v(" "),s("p",[_._v("为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("名称")]),_._v(" "),s("th",[_._v("占用空间大小")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("PAGE_N_DIR_SLOTS")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("在页目录中的槽数量")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_HEAP_TOP")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("还未使用的空间最小地址，也就是说从该地址之后就是"),s("code",[_._v("Free Space")])])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_N_HEAP")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_FREE")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("第一个已经标记为删除的记录的记录地址（各个已删除的记录通过"),s("code",[_._v("next_record")]),_._v("也会组成一个单链表，这个单链表中的记录可以被重新利用）")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_GARBAGE")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("已删除记录占用的字节数")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_LAST_INSERT")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("最后插入记录的位置")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_DIRECTION")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("记录插入的方向")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_N_DIRECTION")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("一个方向连续插入的记录数量")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_N_RECS")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_MAX_TRX_ID")]),_._v(" "),s("td",[_._v("8字节")]),_._v(" "),s("td",[_._v("修改当前页的最大事务ID，该值仅在二级索引中定义")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_LEVEL")]),_._v(" "),s("td",[_._v("2字节")]),_._v(" "),s("td",[_._v("当前页在B+树中所处的层级")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_INDEX_ID")]),_._v(" "),s("td",[_._v("8字节")]),_._v(" "),s("td",[_._v("索引ID，表示当前页属于哪个索引")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_BTR_SEG_LEAF")]),_._v(" "),s("td",[_._v("10字节")]),_._v(" "),s("td",[_._v("B+树叶子段的头部信息，仅在B+树的Root页定义")])]),_._v(" "),s("tr",[s("td",[_._v("PAGE_BTR_SEG_TOP")]),_._v(" "),s("td",[_._v("10字节")]),_._v(" "),s("td",[_._v("B+树非叶子段的头部信息，仅在B+树的Root页定义")])])])]),_._v(" "),s("h2",{attrs:{id:"_3-innodb行格式-或记录格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-innodb行格式-或记录格式"}},[_._v("#")]),_._v(" 3. InnoDB行格式（或记录格式）")]),_._v(" "),s("h3",{attrs:{id:"_3-1-指定行格式的语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-指定行格式的语法"}},[_._v("#")]),_._v(" 3.1 指定行格式的语法")]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("ALTER TABLE 表名 ROW_FORMAT=行格式名称\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h3",{attrs:{id:"_3-2-compact行格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-compact行格式"}},[_._v("#")]),_._v(" 3.2 COMPACT行格式")]),_._v(" "),s("p",[_._v("在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301939611.png",alt:"image-20220330193949517"}})]),_._v(" "),s("h4",{attrs:{id:"_3-2-1-变长字段长度列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-变长字段长度列表"}},[_._v("#")]),_._v(" 3.2.1 变长字段长度列表")]),_._v(" "),s("p",[_._v("MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为"),s("code",[_._v("变长字段")]),_._v("，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。"),s("code",[_._v("在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。")])]),_._v(" "),s("blockquote",[s("p",[_._v("注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。")])]),_._v(" "),s("h4",{attrs:{id:"_3-2-2-null值列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-null值列表"}},[_._v("#")]),_._v(" 3.2.2 NULL值列表")]),_._v(" "),s("p",[_._v("Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。\n"),s("strong",[_._v("为什么定义NULL值列表？")]),_._v("\n之所以要存储NULL是因为数据都是需要对齐的，如果"),s("code",[_._v("没有标注出来NULL值的位置")]),_._v("，就有可能在查询数据的时候"),s("code",[_._v("出现混乱")]),_._v("。如果使用"),s("code",[_._v("一个特定的符号")]),_._v("放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：")]),_._v(" "),s("ol",[s("li",[_._v("二进制位的值为1时，代表该列的值为NULL。")]),_._v(" "),s("li",[_._v("二进制位的值为0时，代表该列的值不为NULL。")])]),_._v(" "),s("blockquote",[s("p",[_._v("注意：同样顺序也是反过来存放的")])]),_._v(" "),s("h4",{attrs:{id:"_3-2-3-记录头信息-5字节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-记录头信息-5字节"}},[_._v("#")]),_._v(" 3.2.3 记录头信息（5字节）")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301945235.png",alt:"image-20220330194534127"}})]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("名称")]),_._v(" "),s("th",[_._v("大小（单位：bit）")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[s("code",[_._v("预留位1")])]),_._v(" "),s("td",[_._v("1")]),_._v(" "),s("td",[_._v("没有使用")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("预留位2")])]),_._v(" "),s("td",[_._v("1")]),_._v(" "),s("td",[_._v("没有使用")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("delete_mask")])]),_._v(" "),s("td",[_._v("1")]),_._v(" "),s("td",[_._v("标记该记录是否被删除")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("mini_rec_mask")])]),_._v(" "),s("td",[_._v("1")]),_._v(" "),s("td",[_._v("B+树的每层非叶子节点中的最小记录都会添加该标记")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("n_owned")])]),_._v(" "),s("td",[_._v("4")]),_._v(" "),s("td",[_._v("表示当前记录拥有的记录数")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("heap_no")])]),_._v(" "),s("td",[_._v("13")]),_._v(" "),s("td",[_._v("表示当前记录在记录堆的位置信息")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("record_type")])]),_._v(" "),s("td",[_._v("3")]),_._v(" "),s("td",[_._v("表示当前记录的类型，"),s("code",[_._v("0")]),_._v("表示普通记录，"),s("code",[_._v("1")]),_._v("表示B+树非叶子节点记录，"),s("code",[_._v("2")]),_._v("表示最小记录，"),s("code",[_._v("3")]),_._v("表示最大记录")])]),_._v(" "),s("tr",[s("td",[s("code",[_._v("next_record")])]),_._v(" "),s("td",[_._v("16")]),_._v(" "),s("td",[_._v("表示下一条记录的相对位置")])])])]),_._v(" "),s("ul",[s("li",[s("code",[_._v("delete_mask")]),_._v("：这个属性标记着当前记录是否被删除，占用1个二进制位。\n"),s("ul",[s("li",[_._v("值为0：代表记录并没有被删除")]),_._v(" "),s("li",[_._v("值为1：代表记录被删除掉了")])])])]),_._v(" "),s("p",[s("strong",[_._v("被删除的记录为什么还在页中存储呢？")]),_._v("\n你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要"),s("code",[_._v("重新排列，导致性能消耗")]),_._v("。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的"),s("code",[_._v("垃圾链表")]),_._v("，在这个链表中的记录占用的空间称之为"),s("code",[_._v("可重用空间")]),_._v("，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。")]),_._v(" "),s("ul",[s("li",[s("code",[_._v("min_rec_mask")]),_._v("：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。")]),_._v(" "),s("li",[s("code",[_._v("record_type")]),_._v("：这个属性表示当前记录的类型，一共有4种类型的记录：\n"),s("ul",[s("li",[_._v("0：表示普通记录")]),_._v(" "),s("li",[_._v("1：表示B+树非叶节点记录")]),_._v(" "),s("li",[_._v("2：表示最小记录")]),_._v(" "),s("li",[_._v("3：表示最大记录")])])]),_._v(" "),s("li",[s("code",[_._v("heap_no")]),_._v("：这个属性表示当前记录在本页中的位置。")])]),_._v(" "),s("p",[s("strong",[_._v("怎么不见heap_no值为0和1的记录呢")]),_._v("？\nMySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为"),s("code",[_._v("伪记录")]),_._v("或者"),s("code",[_._v("虚拟记录")]),_._v("。这两个伪记录一个代表"),s("code",[_._v("最小记录")]),_._v("，一个代表"),s("code",[_._v("最大记录")]),_._v("。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前")]),_._v(" "),s("ul",[s("li",[s("code",[_._v("n_owned")]),_._v("：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段")]),_._v(" "),s("li",[s("code",[_._v("next_record")]),_._v("：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的"),s("code",[_._v("地址偏移量")]),_._v("。")])]),_._v(" "),s("h4",{attrs:{id:"_3-2-4-记录的真实数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-记录的真实数据"}},[_._v("#")]),_._v(" 3.2.4 记录的真实数据")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("列名")]),_._v(" "),s("th",[_._v("是否必须")]),_._v(" "),s("th",[_._v("占用空间")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("row_id")]),_._v(" "),s("td",[_._v("否")]),_._v(" "),s("td",[_._v("6字节")]),_._v(" "),s("td",[_._v("行ID，唯一标识一条记录")])]),_._v(" "),s("tr",[s("td",[_._v("transaction_id")]),_._v(" "),s("td",[_._v("是")]),_._v(" "),s("td",[_._v("6字节")]),_._v(" "),s("td",[_._v("事务ID")])]),_._v(" "),s("tr",[s("td",[_._v("roll_pointer")]),_._v(" "),s("td",[_._v("是")]),_._v(" "),s("td",[_._v("7字节")]),_._v(" "),s("td",[_._v("回滚指针")])])])]),_._v(" "),s("p",[_._v("一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。")]),_._v(" "),s("h3",{attrs:{id:"_3-3-dynamic和compressed行格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-dynamic和compressed行格式"}},[_._v("#")]),_._v(" 3.3 Dynamic和Compressed行格式")]),_._v(" "),s("p",[_._v("我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为"),s("code",[_._v("行溢出")])]),_._v(" "),s("p",[_._v("在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行"),s("code",[_._v("分页存储")]),_._v("，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为"),s("code",[_._v("页的扩展")]),_._v("。")]),_._v(" "),s("p",[_._v("在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧")]),_._v(" "),s("ul",[s("li",[_._v("Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。")]),_._v(" "),s("li",[_._v("Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。")])]),_._v(" "),s("h2",{attrs:{id:"_4-区、段和碎片区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-区、段和碎片区"}},[_._v("#")]),_._v(" 4. 区、段和碎片区")]),_._v(" "),s("h3",{attrs:{id:"_4-1-为什么要有区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-为什么要有区"}},[_._v("#")]),_._v(" 4.1 为什么要有区？")]),_._v(" "),s("p",[s("code",[_._v("B+")]),_._v("树的每一层中的页都会形成一个双向链表，如果是以"),s("code",[_._v("页为单位")]),_._v("来分配存储空间的话，双向链表相邻的两个页之间的"),s("code",[_._v("物理位置可能离得非常远")]),_._v("。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的"),s("code",[_._v("随机I/O")]),_._v("。再一次强调，磁盘的速度和内存的速度差了好几个数量级，"),s("code",[_._v("随机I/O是非常慢")]),_._v("的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的"),s("code",[_._v("顺序I/O")]),_._v("。")]),_._v(" "),s("p",[_._v("引入"),s("code",[_._v("区")]),_._v("的概念，一个区就是物理位置上连续的"),s("code",[_._v("64个页")]),_._v("。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB="),s("code",[_._v("1MB")]),_._v("。在表中"),s("code",[_._v("数据量大")]),_._v("的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照"),s("code",[_._v("区为单位分配")]),_._v("，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成"),s("code",[_._v("一点点空间的浪费")]),_._v("（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，"),s("code",[_._v("功大于过")]),_._v("！")]),_._v(" "),s("h3",{attrs:{id:"_4-2-为什么要有段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-为什么要有段"}},[_._v("#")]),_._v(" 4.2 为什么要有段？")]),_._v(" "),s("p",[_._v("对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的"),s("code",[_._v("叶子节点")]),_._v("和"),s("code",[_._v("非叶子节点")]),_._v("进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个"),s("code",[_._v("段（segment）")]),_._v("，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个"),s("code",[_._v("叶子节点段")]),_._v("，一个"),s("code",[_._v("非叶子节点段")]),_._v("。")]),_._v(" "),s("p",[_._v("除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有"),s("code",[_._v("数据段")]),_._v("、"),s("code",[_._v("索引段")]),_._v("、"),s("code",[_._v("回滚段")]),_._v("。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。")]),_._v(" "),s("p",[_._v("在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。")]),_._v(" "),s("p",[_._v("段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。")]),_._v(" "),s("h3",{attrs:{id:"_4-3-为什么要有碎片区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-为什么要有碎片区"}},[_._v("#")]),_._v(" 4.3 为什么要有碎片区？")]),_._v(" "),s("p",[_._v("默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以**默认情况下一个只存在几条记录的小表也需要2M的存储空间么？**以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常"),s("code",[_._v("纯粹")]),_._v("的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。")]),_._v(" "),s("p",[_._v("为了考虑以完整的区为单位分配给某个段对于"),s("code",[_._v("数据量较小")]),_._v("的表太浪费存储空间的这种情况，InnoDB提出了一个"),s("code",[_._v("碎片（fragment）区")]),_._v("的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。"),s("code",[_._v("碎片区直属于表空间")]),_._v("，并不属于任何一个段。")]),_._v(" "),s("p",[_._v("所以此后为某个段分配存储空间的策略是这样的：")]),_._v(" "),s("ul",[s("li",[_._v("在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。")]),_._v(" "),s("li",[_._v("当某个段已经占用了"),s("code",[_._v("32个碎片区")]),_._v("页面之后，就会申请以完整的区为单位来分配存储空间。")])]),_._v(" "),s("p",[_._v("所以现在段不能仅定义为是某些区的集合，更精确的应该是"),s("code",[_._v("某些零散的页面")]),_._v("已经"),s("code",[_._v("一些完整的区")]),_._v("的集合。")]),_._v(" "),s("h3",{attrs:{id:"_4-4-区的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-区的分类"}},[_._v("#")]),_._v(" 4.4 区的分类")]),_._v(" "),s("p",[_._v("区大体上可以分为4种类型：")]),_._v(" "),s("ul",[s("li",[s("code",[_._v("空闲的区(FREE)")]),_._v("：现在还没有用到这个区中的任何页面。")]),_._v(" "),s("li",[s("code",[_._v("有剩余空间的碎片区(FREE_FRAG)")]),_._v("：表示碎片区中还有可用的页面。")]),_._v(" "),s("li",[s("code",[_._v("没有剩余空间的碎片区(FULL_FRAG)")]),_._v("：表示碎片区中的所有页面都被使用，没有空闲页面。")]),_._v(" "),s("li",[s("code",[_._v("附属于某个段的区(FSEG)")]),_._v("：每一索引都可以分为叶子节点段和非叶子节点段")])]),_._v(" "),s("p",[_._v("处于"),s("code",[_._v("FREE")]),_._v("、"),s("code",[_._v("FREE_FRAG")]),_._v("以及"),s("code",[_._v("FULL_FRAG")]),_._v("这三种状态的区都是独立的，直属于表空间。而处于"),s("code",[_._v("FSEG")]),_._v("状态的区是附属于某个段的。")]),_._v(" "),s("h1",{attrs:{id:"第2章-索引的创建与设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第2章-索引的创建与设计原则"}},[_._v("#")]),_._v(" 第2章 索引的创建与设计原则")]),_._v(" "),s("h2",{attrs:{id:"_1-索引的声明与使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引的声明与使用"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("索引的声明与使用")])]),_._v(" "),s("h3",{attrs:{id:"_1-1-索引的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-索引的分类"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.1")]),_._v(" "),s("strong",[_._v("索引的分类")])]),_._v(" "),s("ul",[s("li",[_._v("从"),s("code",[_._v("功能逻辑")]),_._v("上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。")]),_._v(" "),s("li",[_._v("按照"),s("code",[_._v("物理实现方式")]),_._v("，索引可以分为 2 种：聚簇索引和非聚簇索引。")]),_._v(" "),s("li",[_._v("按照"),s("code",[_._v("作用字段个数")]),_._v("进行划分，分成单列索引和联合索引。")])]),_._v(" "),s("h3",{attrs:{id:"_1-2-创建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-创建索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.2")]),_._v(" "),s("strong",[_._v("创建索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE table_name [col_name data_type] \n[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("ul",[s("li",[s("code",[_._v("UNIQUE")]),_._v("、"),s("code",[_._v("FULLTEXT")]),_._v("和"),s("code",[_._v("SPATIAL")]),_._v("为可选参数，分别表示唯一索引、全文索引和空间索引；")]),_._v(" "),s("li",[s("code",[_._v("INDEX")]),_._v("与"),s("code",[_._v("KEY")]),_._v("为同义词，两者的作用相同，用来指定创建索引；")]),_._v(" "),s("li",[s("code",[_._v("index_name")]),_._v("指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；")]),_._v(" "),s("li",[s("code",[_._v("col_name")]),_._v("为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；")]),_._v(" "),s("li",[s("code",[_._v("length")]),_._v("为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；")]),_._v(" "),s("li",[s("code",[_._v("ASC")]),_._v("或"),s("code",[_._v("DESC")]),_._v("指定升序或者降序的索引值存储。")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("创建普通索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE book( \n    book_id INT , \n    book_name VARCHAR(100), \n    authors VARCHAR(100), \n    info VARCHAR(100) , \n    comment VARCHAR(100), \n    year_publication YEAR, \n    INDEX(year_publication) \n);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br"),s("span",{staticClass:"line-number"},[_._v("8")]),s("br"),s("span",{staticClass:"line-number"},[_._v("9")]),s("br")])]),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("创建唯一索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE test1( \n    id INT NOT NULL, \n    name varchar(30) NOT NULL, \n    UNIQUE INDEX uk_idx_id(id) \n);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br")])]),s("p",[s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("主键索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE student ( \n    id INT(10) UNSIGNED AUTO_INCREMENT, \n    student_no VARCHAR(200),\n    student_name VARCHAR(200), \n    PRIMARY KEY(id) \n);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br")])]),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("# 删除主键索引\nALTER TABLE student drop PRIMARY KEY ;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("p",[s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("创建单列索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE test2( \n    id INT NOT NULL, \n    name CHAR(50) NULL, \n    INDEX single_idx_name(name(20)) \n);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br")])]),s("p",[s("strong",[_._v("5.")]),_._v(" "),s("strong",[_._v("创建组合索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE test3( \n    id INT(11) NOT NULL, \n    name CHAR(30) NOT NULL, \n    age INT(11) NOT NULL, \n    info VARCHAR(255), \n    INDEX multi_idx(id,name,age) \n);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br")])]),s("p",[s("strong",[_._v("6.")]),_._v(" "),s("strong",[_._v("创建全文索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE `papers` ( \n    id` int(10) unsigned NOT NULL AUTO_INCREMENT, \n    `title` varchar(200) DEFAULT NULL, \n    `content` text, PRIMARY KEY (`id`), \n    FULLTEXT KEY `title` (`title`,`content`) \n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br")])]),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[s("strong",[_._v("7.")]),_._v(" "),s("strong",[_._v("创建空间索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE test5( \n    geo GEOMETRY NOT NULL, \n    SPATIAL INDEX spa_idx_geo(geo) \n) ENGINE=MyISAM;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br")])]),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("在已经存在的表上创建索引")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("使用ALTER TABLE语句创建索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("ALTER TABLE table_name \nADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("使用CREATE INDEX创建索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name \nON table_name (col_name[length],...) [ASC | DESC]\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("h3",{attrs:{id:"_1-3-删除索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-删除索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.3")]),_._v(" "),s("strong",[_._v("删除索引")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("使用ALTER TABLE删除索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("ALTER TABLE table_name DROP INDEX index_name;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("使用DROP INDEX语句删除索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("DROP INDEX index_name ON table_name;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h2",{attrs:{id:"_2-mysql8-0索引新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-mysql8-0索引新特性"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2. MySQL8.0索引新特性")])]),_._v(" "),s("h3",{attrs:{id:"_2-1-支持降序索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-支持降序索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.1")]),_._v(" "),s("strong",[_._v("支持降序索引")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h3",{attrs:{id:"_2-2-隐藏索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-隐藏索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.2")]),_._v(" "),s("strong",[_._v("隐藏索引")])]),_._v(" "),s("p",[_._v("从MySQL 8.x开始支持"),s("code",[_._v("隐藏索引（invisible indexes）")]),_._v("，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。"),s("code",[_._v("这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除")]),_._v("。")]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("创建表时直接创建")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE tablename( \n    propname1 type1[CONSTRAINT1], \n    propname2 type2[CONSTRAINT2], \n    ……\n    propnamen typen, \n    INDEX [indexname](propname1 [(length)]) INVISIBLE \n);\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br")])]),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("在已经存在的表上创建")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE INDEX indexname \nON tablename(propname[(length)]) INVISIBLE;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("p",[s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("通过ALTER TABLE语句创建")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("ALTER TABLE tablename \nADD INDEX indexname (propname [(length)]) INVISIBLE;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("p",[s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("切换索引可见状态")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 \nALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("h2",{attrs:{id:"_3-索引的设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-索引的设计原则"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("索引的设计原则")])]),_._v(" "),s("h3",{attrs:{id:"_3-1-哪些情况适合创建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-哪些情况适合创建索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3.1")]),_._v(" "),s("strong",[_._v("哪些情况适合创建索引")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("字段的数值有唯一性的限制")])]),_._v(" "),s("p",[_._v("索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果"),s("code",[_._v("某个字段是唯一的")]),_._v("，就可以直接"),s("code",[_._v("创建唯一性索引")]),_._v("，或者"),s("code",[_._v("主键索引")]),_._v("。这样可以更快速地通过该索引来确定某条记录。")]),_._v(" "),s("blockquote",[s("p",[_._v("业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）")]),_._v(" "),s("p",[_._v("说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。")])]),_._v(" "),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("频繁作为")]),_._v(" "),s("strong",[_._v("WHERE")]),_._v(" "),s("strong",[_._v("查询条件的字段")])]),_._v(" "),s("p",[_._v("某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。")]),_._v(" "),s("p",[s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("经常")]),_._v(" "),s("strong",[_._v("GROUP BY")]),_._v(" "),s("strong",[_._v("和")]),_._v(" "),s("strong",[_._v("ORDER BY")]),_._v(" "),s("strong",[_._v("的列")])]),_._v(" "),s("p",[_._v("索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要"),s("code",[_._v("对分组或者排序的字段进行索引")]),_._v("。如果待排序的列有多个，那么可以在这些列上建立"),s("code",[_._v("组合索引")]),_._v("。")]),_._v(" "),s("p",[s("strong",[_._v("4. UPDATE、DELETE")]),_._v(" "),s("strong",[_._v("的")]),_._v(" "),s("strong",[_._v("WHERE")]),_._v(" "),s("strong",[_._v("条件列")])]),_._v(" "),s("p",[_._v("对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。"),s("strong",[_._v("如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。")])]),_._v(" "),s("p",[s("strong",[_._v("5.DISTINCT")]),_._v(" "),s("strong",[_._v("字段需要创建索引")])]),_._v(" "),s("p",[_._v("有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。")]),_._v(" "),s("p",[s("strong",[_._v("6.")]),_._v(" "),s("strong",[_._v("多表")]),_._v(" "),s("strong",[_._v("JOIN")]),_._v(" "),s("strong",[_._v("连接操作时，创建索引注意事项")])]),_._v(" "),s("p",[_._v("首先，"),s("code",[_._v("连接表的数量尽量不要超过 3 张")]),_._v("，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。")]),_._v(" "),s("p",[_._v("其次，"),s("code",[_._v("对 WHERE 条件创建索引")]),_._v("，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。")]),_._v(" "),s("p",[_._v("最后，"),s("code",[_._v("对用于连接的字段创建索引")]),_._v("，并且该字段在多张表中的"),s("code",[_._v("类型必须一致")]),_._v("。")]),_._v(" "),s("p",[s("strong",[_._v("7.")]),_._v(" "),s("strong",[_._v("使用列的类型小的创建索引")])]),_._v(" "),s("p",[_._v("我们这里所说的"),s("code",[_._v("类型大小")]),_._v("指的就是该类型表示的数据范围的大小。")]),_._v(" "),s("ul",[s("li",[_._v("数据类型越小，在查询时进行的比较操作越快")]),_._v(" "),s("li",[_._v("数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以"),s("code",[_._v("放下更多的记录")]),_._v("，从而减少磁盘"),s("code",[_._v("I/O")]),_._v("带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。")])]),_._v(" "),s("p",[_._v("这个建议对于表的"),s("code",[_._v("主键来说更加适用")]),_._v("，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。")]),_._v(" "),s("p",[s("strong",[_._v("8.")]),_._v(" "),s("strong",[_._v("使用字符串前缀创建索引")])]),_._v(" "),s("p",[_._v("区分度计算公式：")]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("count(distinct left(列名, 索引长度))/count(*)\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[s("strong",[_._v("拓展：Alibaba《Java开发手册》")])]),_._v(" "),s("p",[_._v("【"),s("code",[_._v("强制")]),_._v("】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。")]),_._v(" "),s("p",[_._v("说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会"),s("code",[_._v("高达 90% 以上")]),_._v("。")]),_._v(" "),s("p",[s("strong",[_._v("9.")]),_._v(" "),s("strong",[_._v("区分度高(散列性高)的列适合作为索引")])]),_._v(" "),s("p",[s("code",[_._v("列的基数")]),_._v("指的是某一列中不重复数据的个数，比方说某个列包含值"),s("code",[_._v("2,5,8,2,5,8,2,5,8")]),_._v("，虽然有"),s("code",[_._v("9")]),_._v("条记录，但该列的基数却是"),s("code",[_._v("3")]),_._v("。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。")]),_._v(" "),s("p",[_._v("可以使用公式"),s("code",[_._v("select count(distinct a)/count(*) from t1")]),_._v("计算区分度，越接近1越好，一般超过"),s("code",[_._v("33%")]),_._v("就算是比较高效的索引了。")]),_._v(" "),s("p",[_._v("拓展：联合索引把区分度高（散列性高）的列放在前面。")]),_._v(" "),s("p",[s("strong",[_._v("10.")]),_._v(" "),s("strong",[_._v("使用最频繁的列放到联合索引的左侧")])]),_._v(" "),s("p",[s("strong",[_._v("11.")]),_._v(" "),s("strong",[_._v("在多个字段都要创建索引的情况下，联合索引优于单值索引")])]),_._v(" "),s("h3",{attrs:{id:"_3-2-限制索引的数目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-限制索引的数目"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3.2")]),_._v(" "),s("strong",[_._v("限制索引的数目")])]),_._v(" "),s("p",[_._v("在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量"),s("code",[_._v("不超过6个")]),_._v("。原因：")]),_._v(" "),s("ul",[s("li",[_._v("每个索引都需要占用"),s("code",[_._v("磁盘空间")]),_._v("，索引越多，需要的磁盘空间就越大。")]),_._v(" "),s("li",[_._v("索引会影响"),s("code",[_._v("INSERT、DELETE、UPDATE等语句的性能")]),_._v("，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。")]),_._v(" "),s("li",[_._v("优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的"),s("code",[_._v("索引来进行评估")]),_._v("，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。")])]),_._v(" "),s("h3",{attrs:{id:"_3-3-哪些情况不适合创建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-哪些情况不适合创建索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3.3")]),_._v(" "),s("strong",[_._v("哪些情况不适合创建索引")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("在where中使用不到的字段，不要设置索引")])]),_._v(" "),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("数据量小的表最好不要使用索引")])]),_._v(" "),s("p",[s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("有大量重复数据的列上不要建立索引")])]),_._v(" "),s("p",[s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("避免对经常更新的表创建过多的索引")])]),_._v(" "),s("p",[s("strong",[_._v("5.")]),_._v(" "),s("strong",[_._v("不建议用无序的值作为索引")])]),_._v(" "),s("p",[_._v("例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。")]),_._v(" "),s("p",[s("strong",[_._v("6.")]),_._v(" "),s("strong",[_._v("删除不再使用或者很少使用的索引")])]),_._v(" "),s("p",[s("strong",[_._v("7.")]),_._v(" "),s("strong",[_._v("不要定义冗余或重复的索引")])]),_._v(" "),s("h1",{attrs:{id:"第3章-性能分析工具的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第3章-性能分析工具的使用"}},[_._v("#")]),_._v(" 第3章 性能分析工具的使用")]),_._v(" "),s("h2",{attrs:{id:"_1-统计sql的查询成本-last-query-cost"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-统计sql的查询成本-last-query-cost"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("统计SQL的查询成本：last_query_cost")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("SHOW STATUS LIKE 'last_query_cost';\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[_._v("使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。")]),_._v(" "),s("blockquote",[s("p",[_._v("SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：")]),_._v(" "),s("ol",[s("li",[s("code",[_._v("位置决定效率")]),_._v("。如果页就在数据库"),s("code",[_._v("缓冲池")]),_._v("中，那么效率是最高的，否则还需要从"),s("code",[_._v("内存")]),_._v("或者"),s("code",[_._v("磁盘")]),_._v("中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。")]),_._v(" "),s("li",[s("code",[_._v("批量决定效率")]),_._v("。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。")])]),_._v(" "),s("p",[_._v("所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到"),s("code",[_._v("缓冲池")]),_._v("中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。")])]),_._v(" "),s("h2",{attrs:{id:"_2-定位执行慢的sql-慢查询日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-定位执行慢的sql-慢查询日志"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("定位执行慢的SQL：慢查询日志")])]),_._v(" "),s("p",[_._v("MySQL的慢查询日志，用来记录在MySQL中"),s("code",[_._v("响应时间超过阈值")]),_._v("的语句，具体指运行时间超过"),s("code",[_._v("long_query_time")]),_._v("的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为"),s("code",[_._v("10")]),_._v("，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。")]),_._v(" "),s("p",[_._v("默认情况下，MySQL数据库"),s("code",[_._v("没有开启慢查询日志")]),_._v("，需要我们手动来设置这个参数。"),s("code",[_._v("如果不是调优需要的话，一般不建议启动该参数")]),_._v("，因为开启慢查询日志会或多或少带来一定的性能影响。")]),_._v(" "),s("h3",{attrs:{id:"_2-1-开启慢查询日志参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-开启慢查询日志参数"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.1")]),_._v(" "),s("strong",[_._v("开启慢查询日志参数")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("开启slow_query_log")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("set global slow_query_log='ON';\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[_._v("查看下慢查询日志是否开启，以及慢查询日志文件的位置：")]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("show variables like `%slow_query_log%`;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("修改long_query_time阈值")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("show variables like '%long_query_time%';\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 \nmysql > set global long_query_time = 1; \nmysql> show global variables like '%long_query_time%'; \n\nmysql> set long_query_time=1; \nmysql> show variables like '%long_query_time%';\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br")])]),s("h3",{attrs:{id:"_2-2-查看慢查询数目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-查看慢查询数目"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.2")]),_._v(" "),s("strong",[_._v("查看慢查询数目")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("SHOW GLOBAL STATUS LIKE '%Slow_queries%';\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h3",{attrs:{id:"_2-3-慢查询日志分析工具-mysqldumpslow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-慢查询日志分析工具-mysqldumpslow"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.3")]),_._v(" "),s("strong",[_._v("慢查询日志分析工具：mysqldumpslow")])]),_._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("#得到返回记录集最多的10个SQL ")]),_._v("\nmysqldumpslow -s r -t "),s("span",{pre:!0,attrs:{class:"token number"}},[_._v("10")]),_._v(" /var/lib/mysql/atguigu-slow.log \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("#得到访问次数最多的10个SQL ")]),_._v("\nmysqldumpslow -s c -t "),s("span",{pre:!0,attrs:{class:"token number"}},[_._v("10")]),_._v(" /var/lib/mysql/atguigu-slow.log\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("#得到按照时间排序的前10条里面含有左连接的查询语句 ")]),_._v("\nmysqldumpslow -s t -t "),s("span",{pre:!0,attrs:{class:"token number"}},[_._v("10")]),_._v(" -g "),s("span",{pre:!0,attrs:{class:"token string"}},[_._v('"left join"')]),_._v(" /var/lib/mysql/atguigu-slow.log \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 ")]),_._v("\nmysqldumpslow -s r -t "),s("span",{pre:!0,attrs:{class:"token number"}},[_._v("10")]),_._v(" /var/lib/mysql/atguigu-slow.log "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[_._v("more")]),_._v("\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br"),s("span",{staticClass:"line-number"},[_._v("8")]),s("br")])]),s("h3",{attrs:{id:"_2-4-关闭慢查询日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-关闭慢查询日志"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.4")]),_._v(" "),s("strong",[_._v("关闭慢查询日志")])]),_._v(" "),s("p",[s("strong",[_._v("方式1：永久性方式")])]),_._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token section"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("[")]),s("span",{pre:!0,attrs:{class:"token section-name selector"}},[_._v("mysqld")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("]")])]),_._v(" \n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[_._v("slow_query_log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[_._v("OFF")]),_._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("#或")]),_._v("\n"),s("span",{pre:!0,attrs:{class:"token section"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("[")]),s("span",{pre:!0,attrs:{class:"token section-name selector"}},[_._v("mysqld")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("]")])]),_._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("#slow_query_log =OFF")]),_._v("\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br")])]),s("p",[s("strong",[_._v("方式2：临时性方式")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("SET GLOBAL slow_query_log=off;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h2",{attrs:{id:"_3-查看-sql-执行成本-show-profile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-查看-sql-执行成本-show-profile"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("查看")]),_._v(" "),s("strong",[_._v("SQL")]),_._v(" "),s("strong",[_._v("执行成本：SHOW PROFILE")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("show variables like 'profiling';\n#开启\nset profiling = 'ON';\n#查看\nshow profiles;\nshow profile cpu,block io for query 2;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br")])]),s("h2",{attrs:{id:"_4-分析查询语句-explain"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-分析查询语句-explain"}},[_._v("#")]),_._v(" "),s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("分析查询语句：EXPLAIN")])]),_._v(" "),s("h3",{attrs:{id:"_4-1-基本语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-基本语法"}},[_._v("#")]),_._v(" "),s("strong",[_._v("4.1")]),_._v(" "),s("strong",[_._v("基本语法")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("EXPLAIN SELECT select_options \n#或者\nDESCRIBE SELECT select_options\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br")])]),s("p",[_._v("EXPLAIN 语句输出的各个列的作用如下：")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("列名")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("id")]),_._v(" "),s("td",[_._v("在一个大的查询语句中每个SELECT关键字都对应一个"),s("code",[_._v("唯一的id")])])]),_._v(" "),s("tr",[s("td",[_._v("select_type")]),_._v(" "),s("td",[_._v("SELECT关键字对应的那个查询的类型")])]),_._v(" "),s("tr",[s("td",[_._v("table")]),_._v(" "),s("td",[_._v("表名")])]),_._v(" "),s("tr",[s("td",[_._v("partitions")]),_._v(" "),s("td",[_._v("匹配的分区信息")])]),_._v(" "),s("tr",[s("td",[_._v("type")]),_._v(" "),s("td",[_._v("针对单表的访问方法")])]),_._v(" "),s("tr",[s("td",[_._v("possible_keys")]),_._v(" "),s("td",[_._v("可能用到的索引")])]),_._v(" "),s("tr",[s("td",[_._v("key")]),_._v(" "),s("td",[_._v("实际上使用的索引")])]),_._v(" "),s("tr",[s("td",[_._v("key_len")]),_._v(" "),s("td",[_._v("实际使用到的索引长度")])]),_._v(" "),s("tr",[s("td",[_._v("ref")]),_._v(" "),s("td",[_._v("当使用索引列等值查询时，与索引列进行等值匹配的对象信息")])]),_._v(" "),s("tr",[s("td",[_._v("rows")]),_._v(" "),s("td",[_._v("预估的需要读取的记录条数")])]),_._v(" "),s("tr",[s("td",[_._v("filtered")]),_._v(" "),s("td",[_._v("某个表经过搜索条件过滤后剩余记录条数的百分比")])]),_._v(" "),s("tr",[s("td",[_._v("Extra")]),_._v(" "),s("td",[_._v("一些额外的信息")])])])]),_._v(" "),s("h3",{attrs:{id:"_4-2-explain各列作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-explain各列作用"}},[_._v("#")]),_._v(" "),s("strong",[_._v("4.2 EXPLAIN各列作用")])]),_._v(" "),s("p",[s("strong",[_._v("1. table")])]),_._v(" "),s("p",[_._v("不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行"),s("code",[_._v("单表访问")]),_._v("的，所以MySQL规定"),s("strong",[_._v("EXPLAIN语句输出的每条记录都对应着某个单表的访问方法")]),_._v("，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。")]),_._v(" "),s("p",[s("strong",[_._v("2. id")])]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("id如果相同，可以认为是一组，从上往下顺序执行")])]),_._v(" "),s("li",[s("strong",[_._v("在所有组中，id值越大，优先级越高，越先执行")])]),_._v(" "),s("li",[s("strong",[_._v("关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好")])])]),_._v(" "),s("p",[s("strong",[_._v("3. select_type")])]),_._v(" "),s("p",[s("strong",[_._v("4. partitions")])]),_._v(" "),s("p",[s("strong",[_._v("5. type（重点）")])]),_._v(" "),s("p",[s("strong",[_._v("结果值从最好到最坏依次是：")]),_._v(" "),s("strong",[_._v("system > const > eq_ref > ref")]),_._v(" "),s("strong",[_._v("> fulltext > ref_or_null > index_merge > unique_subquery > index_subquery >")]),_._v(" "),s("strong",[_._v("range > index > ALL")])]),_._v(" "),s("p",[s("strong",[_._v("SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）")])]),_._v(" "),s("p",[s("strong",[_._v("6. possible_keys和key")])]),_._v(" "),s("p",[s("strong",[_._v("7. key_len（重点）")])]),_._v(" "),s("p",[s("strong",[_._v("key_len的长度计算公式：")])]),_._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) \n\nvarchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)\n\nchar(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) \n\nchar(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br")])]),s("p",[s("strong",[_._v("8. ref")])]),_._v(" "),s("p",[s("strong",[_._v("9. rows（重点）")])]),_._v(" "),s("p",[_._v("预估的需要读取的记录条数")]),_._v(" "),s("p",[s("strong",[_._v("10. filtered")])]),_._v(" "),s("p",[s("strong",[_._v("11. Extra")])]),_._v(" "),s("h2",{attrs:{id:"_5-explain的进一步使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-explain的进一步使用"}},[_._v("#")]),_._v(" "),s("strong",[_._v("5. EXPLAIN的进一步使用")])]),_._v(" "),s("h3",{attrs:{id:"_5-1-explain四种输出格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-explain四种输出格式"}},[_._v("#")]),_._v(" "),s("strong",[_._v("5.1 EXPLAIN四种输出格式")])]),_._v(" "),s("p",[_._v("这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式："),s("code",[_._v("传统格式")]),_._v("，"),s("code",[_._v("JSON格式")]),_._v("，"),s("code",[_._v("TREE格式")]),_._v("以及"),s("code",[_._v("可视化输出")]),_._v("。用户可以根据需要选择适用于自己的格式。")]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("传统格式")])]),_._v(" "),s("p",[s("strong",[_._v("2. JSON格式")])]),_._v(" "),s("p",[_._v("JSON格式：在EXPLAIN单词和真正的查询语句中间加上"),s("code",[_._v("FORMAT=JSON")]),_._v("。用于查看执行成本"),s("code",[_._v("cost_info")])]),_._v(" "),s("p",[s("strong",[_._v("3. TREE格式")])]),_._v(" "),s("p",[_._v("TREE格式是8.0.16版本之后引入的新格式，主要根据查询的"),s("code",[_._v("各个部分之间的关系")]),_._v("和"),s("code",[_._v("各部分的执行顺序")]),_._v("来描述如何查询。")]),_._v(" "),s("p",[s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("可视化输出")])]),_._v(" "),s("p",[_._v("可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。")]),_._v(" "),s("h3",{attrs:{id:"_5-2-show-warnings的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-show-warnings的使用"}},[_._v("#")]),_._v(" "),s("strong",[_._v("5.2 SHOW WARNINGS的使用")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;\n# 查看优化后的执行语句\nmysql> SHOW WARNINGS\\G\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br")])]),s("h2",{attrs:{id:"_6-分析优化器执行计划-trace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-分析优化器执行计划-trace"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.")]),_._v(" "),s("strong",[_._v("分析优化器执行计划：trace")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v('# 开启\nSET optimizer_trace="enabled=on",end_markers_in_json=on; \n# 设置大小\nset optimizer_trace_max_mem_size=1000000;\n# 使用\nselect * from student where id < 10;\nselect * from information_schema.optimizer_trace\\G\n')])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br")])]),s("h2",{attrs:{id:"_7-mysql监控分析视图-sys-schema"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-mysql监控分析视图-sys-schema"}},[_._v("#")]),_._v(" "),s("strong",[_._v("7. MySQL监控分析视图-sys schema")])]),_._v(" "),s("p",[s("strong",[_._v("7.1 Sys schema视图使用场景")])]),_._v(" "),s("p",[s("strong",[_._v("索引情况")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("#1. 查询冗余索引 \nselect * from sys.schema_redundant_indexes; \n#2. 查询未使用过的索引 \nselect * from sys.schema_unused_indexes; \n#3. 查询索引的使用情况 \nselect index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br")])]),s("p",[s("strong",[_._v("表相关")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("# 1. 查询表的访问量 \nselect table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; \n# 2. 查询占用bufferpool较多的表 \nselect object_schema,object_name,allocated,data\nfrom sys.innodb_buffer_stats_by_table order by allocated limit 10; \n# 3. 查看表的全表扫描情况 \nselect * from sys.statements_with_full_table_scans where db='dbname';\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br")])]),s("p",[s("strong",[_._v("语句相关")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("#1. 监控SQL执行的频率 \nselect db,exec_count,query from sys.statement_analysis order by exec_count desc; \n#2. 监控使用了排序的SQL \nselect db,exec_count,first_seen,last_seen,query\nfrom sys.statements_with_sorting limit 1; \n#3. 监控使用了临时表或者磁盘临时表的SQL \nselect db,exec_count,tmp_tables,tmp_disk_tables,query\nfrom sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br"),s("span",{staticClass:"line-number"},[_._v("8")]),s("br")])]),s("p",[s("strong",[_._v("IO相关")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("#1. 查看消耗磁盘IO的文件 \nselect file,avg_read,avg_write,avg_read+avg_write as avg_io\nfrom sys.io_global_by_file_by_bytes order by avg_read limit 10;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br")])]),s("p",[s("strong",[_._v("Innodb")]),_._v(" "),s("strong",[_._v("相关")])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("#1. 行锁阻塞情况 \nselect * from sys.innodb_lock_waits;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("h1",{attrs:{id:"第4章-索引优化与查询优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第4章-索引优化与查询优化"}},[_._v("#")]),_._v(" 第4章 索引优化与查询优化")]),_._v(" "),s("h2",{attrs:{id:"_1-索引失效案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引失效案例"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("索引失效案例")])]),_._v(" "),s("p",[_._v("MySQL中"),s("code",[_._v("提高性能")]),_._v("的一个最有效的方式是对数据表"),s("code",[_._v("设计合理的索引")]),_._v("。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。")]),_._v(" "),s("ul",[s("li",[_._v("使用索引可以"),s("code",[_._v("快速地定位")]),_._v("表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。")]),_._v(" "),s("li",[_._v("如果查询时没有使用索引，查询语句就会"),s("code",[_._v("扫描表中的所有记录")]),_._v("。在数据量大的情况下，这样查询的速度会很慢。")])]),_._v(" "),s("p",[_._v("大多数情况下都（默认）采用"),s("code",[_._v("B+树")]),_._v("来构建索引。只是空间列类型的索引使用"),s("code",[_._v("R-树")]),_._v("，并且MEMORY表还支持"),s("code",[_._v("hash索引")]),_._v("。")]),_._v(" "),s("p",[_._v("其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于"),s("code",[_._v("cost开销(CostBaseOptimizer)")]),_._v("，它不是基于"),s("code",[_._v("规则(Rule-BasedOptimizer)")]),_._v("，也不是基于"),s("code",[_._v("语义")]),_._v("。怎么样开销小就怎么来。另外，"),s("strong",[_._v("SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。")])]),_._v(" "),s("h3",{attrs:{id:"_1-1-全值匹配我最爱"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-全值匹配我最爱"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.1")]),_._v(" "),s("strong",[_._v("全值匹配我最爱")])]),_._v(" "),s("h3",{attrs:{id:"_1-2-最佳左前缀法则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-最佳左前缀法则"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.2")]),_._v(" "),s("strong",[_._v("最佳左前缀法则")])]),_._v(" "),s("p",[_._v("在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。")]),_._v(" "),s("p",[_._v("结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。")]),_._v(" "),s("h3",{attrs:{id:"_1-3-主键插入顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-主键插入顺序"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.3")]),_._v(" "),s("strong",[_._v("主键插入顺序")])]),_._v(" "),s("p",[_._v("对于一个使用"),s("code",[_._v("InnoDB")]),_._v("存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在"),s("code",[_._v("聚簇索引")]),_._v("的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录"),s("code",[_._v("主键值从小到大")]),_._v("的顺序进行排序，所以如果我们"),s("code",[_._v("插入")]),_._v("的记录的"),s("code",[_._v("主键值是依次增大")]),_._v("的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的"),s("code",[_._v("主键值忽小忽大")]),_._v("的话，则可能会造成"),s("code",[_._v("页面分裂")]),_._v("和"),s("code",[_._v("记录移位")]),_._v("。")]),_._v(" "),s("h3",{attrs:{id:"_1-4-计算、函数、类型转换-自动或手动-导致索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-计算、函数、类型转换-自动或手动-导致索引失效"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.4")]),_._v(" "),s("strong",[_._v("计算、函数、类型转换(自动或手动)导致索引失效")])]),_._v(" "),s("h3",{attrs:{id:"_1-5-类型转换导致索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-类型转换导致索引失效"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.5")]),_._v(" "),s("strong",[_._v("类型转换导致索引失效")])]),_._v(" "),s("h3",{attrs:{id:"_1-6-范围条件右边的列索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-范围条件右边的列索引失效"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.6")]),_._v(" "),s("strong",[_._v("范围条件右边的列索引失效")])]),_._v(" "),s("blockquote",[s("p",[_._v("应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）")])]),_._v(" "),s("h3",{attrs:{id:"_1-7-不等于-或者-索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-不等于-或者-索引失效"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.7")]),_._v(" "),s("strong",[_._v("不等于(!= 或者<>)索引失效")])]),_._v(" "),s("h3",{attrs:{id:"_1-8-is-null可以使用索引-is-not-null无法使用索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-is-null可以使用索引-is-not-null无法使用索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.8 is null可以使用索引，is not null无法使用索引")])]),_._v(" "),s("blockquote",[s("p",[_._v("结论：最好在设计数据表的时候就将"),s("code",[_._v("字段设置为 NOT NULL 约束")]),_._v("，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串('')")]),_._v(" "),s("p",[_._v("拓展：同理，在查询中使用"),s("code",[_._v("not like")]),_._v("也无法使用索引，导致全表扫描")])]),_._v(" "),s("h3",{attrs:{id:"_1-9-like以通配符-开头索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-like以通配符-开头索引失效"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.9 like以通配符%开头索引失效")])]),_._v(" "),s("blockquote",[s("p",[_._v("拓展：Alibaba《Java开发手册》")]),_._v(" "),s("p",[_._v("【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。")])]),_._v(" "),s("h3",{attrs:{id:"_1-10-or-前后存在非索引的列-索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-or-前后存在非索引的列-索引失效"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.10 OR")]),_._v(" "),s("strong",[_._v("前后存在非索引的列，索引失效")])]),_._v(" "),s("p",[_._v("在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，"),s("strong",[_._v("OR前后的两个条件中的列都是索引时，查询中才使用索引。")])]),_._v(" "),s("h3",{attrs:{id:"_1-11-数据库和表的字符集统一使用utf8mb4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-数据库和表的字符集统一使用utf8mb4"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.11")]),_._v(" "),s("strong",[_._v("数据库和表的字符集统一使用utf8mb4")])]),_._v(" "),s("p",[_._v("统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的"),s("code",[_._v("字符集")]),_._v("进行比较前需要进行"),s("code",[_._v("转换")]),_._v("会造成索引失效。")]),_._v(" "),s("h2",{attrs:{id:"_2-关联查询优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-关联查询优化"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("关联查询优化")])]),_._v(" "),s("blockquote",[s("p",[_._v("结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现")]),_._v(" "),s("p",[_._v("结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表")]),_._v(" "),s("p",[_._v("结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。"),s("code",[_._v("小表驱动大表")])])]),_._v(" "),s("h3",{attrs:{id:"_2-1-index-nested-loop-join-索引嵌套循环连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-index-nested-loop-join-索引嵌套循环连接"}},[_._v("#")]),_._v(" 2.1 Index Nested-Loop Join（索引嵌套循环连接）")]),_._v(" "),s("p",[_._v("Index Nested-Loop Join其优化的思路主要是为了"),s("code",[_._v("减少内层表数据的匹配次数")]),_._v("，所以要求被驱动表上必须"),s("code",[_._v("有索引")]),_._v("才行。")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png",alt:"image-20220401182649509"}})]),_._v(" "),s("h3",{attrs:{id:"_2-2-block-nested-loop-join-块嵌套循环连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-block-nested-loop-join-块嵌套循环连接"}},[_._v("#")]),_._v(" 2.2 Block Nested-Loop Join（块嵌套循环连接）")]),_._v(" "),s("p",[_._v("如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。")]),_._v(" "),s("p",[_._v("不再是逐条获取驱动表的数据，而是一块一块的获取，引入了"),s("code",[_._v("join buffer缓冲区")]),_._v("，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png",alt:"image-20220401183344880"}})]),_._v(" "),s("h3",{attrs:{id:"_2-3-hash-join"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-hash-join"}},[_._v("#")]),_._v(" 2.3 Hash Join")]),_._v(" "),s("p",[s("strong",[_._v("从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join")])]),_._v(" "),s("ul",[s("li",[_._v("Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。")]),_._v(" "),s("li",[_._v("Hash Join是做"),s("code",[_._v("大数据集连接")]),_._v("时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立"),s("code",[_._v("散列值")]),_._v("，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。\n"),s("ul",[s("li",[_._v("这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。")]),_._v(" "),s("li",[_._v("在表很大的情况下并不能完全放入内存，这时优化器会将它分割成"),s("code",[_._v("若干不同的分区")]),_._v("，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。")]),_._v(" "),s("li",[_._v("它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。")])])])]),_._v(" "),s("h2",{attrs:{id:"_3-子查询优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-子查询优化"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("子查询优化")])]),_._v(" "),s("p",[s("strong",[_._v("子查询是")]),_._v(" "),s("strong",[_._v("MySQL")]),_._v(" "),s("strong",[_._v("的一项重要的功能，可以帮助我们通过一个")]),_._v(" "),s("strong",[_._v("SQL")]),_._v(" **语句实现比较复杂的查询。但是，子查询的执行效率不高。**原因：")]),_._v(" "),s("p",[_._v("① 执行子查询时，MySQL需要为内层查询语句的查询结果"),s("code",[_._v("建立一个临时表")]),_._v("，然后外层查询语句从临时表中查询记录。查询完毕后，再"),s("code",[_._v("撤销这些临时表")]),_._v("。这样会消耗过多的CPU和IO资源，产生大量的慢查询。")]),_._v(" "),s("p",[_._v("② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都"),s("code",[_._v("不会存在索引")]),_._v("，所以查询性能会受到一定的影响。")]),_._v(" "),s("p",[_._v("③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。")]),_._v(" "),s("p",[_._v("**在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询"),s("code",[_._v("不需要建立临时表")]),_._v("，其"),s("code",[_._v("速度比子查询要快")]),_._v("，如果查询中使用索引的话，性能就会更好。")]),_._v(" "),s("blockquote",[s("p",[_._v("结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代")])]),_._v(" "),s("h2",{attrs:{id:"_4-排序优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-排序优化"}},[_._v("#")]),_._v(" "),s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("排序优化")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 "),s("code",[_._v("避免全表扫描")]),_._v("，在 ORDER BY 子句"),s("code",[_._v("避免使用 FileSort 排序")]),_._v("。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。")])]),_._v(" "),s("li",[s("p",[_._v("尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。")])]),_._v(" "),s("li",[s("p",[_._v("无法使用 Index 时，需要对 FileSort 方式进行调优。")])])]),_._v(" "),s("h2",{attrs:{id:"_5-group-by优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-group-by优化"}},[_._v("#")]),_._v(" "),s("strong",[_._v("5. GROUP BY优化")])]),_._v(" "),s("ul",[s("li",[_._v("group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。")]),_._v(" "),s("li",[_._v("group by 先排序再分组，遵照索引建的最佳左前缀法则")]),_._v(" "),s("li",[_._v("当无法使用索引列，可以增大"),s("code",[_._v("max_length_for_sort_data")]),_._v("和"),s("code",[_._v("sort_buffer_size")]),_._v("参数的设置")]),_._v(" "),s("li",[_._v("where效率高于having，能写在where限定的条件就不要写在having中了")]),_._v(" "),s("li",[_._v("减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。")]),_._v(" "),s("li",[_._v("包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。")])]),_._v(" "),s("h2",{attrs:{id:"_6-优化分页查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-优化分页查询"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.")]),_._v(" "),s("strong",[_._v("优化分页查询")])]),_._v(" "),s("p",[s("strong",[_._v("优化思路一")])]),_._v(" "),s("p",[_._v("在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。")]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a\nWHERE t.id = a.id;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br")])]),s("p",[s("strong",[_._v("优化思路二")])]),_._v(" "),s("p",[_._v("该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。")]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h2",{attrs:{id:"_7-优先考虑覆盖索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-优先考虑覆盖索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("7.")]),_._v(" "),s("strong",[_._v("优先考虑覆盖索引")])]),_._v(" "),s("h3",{attrs:{id:"_7-1-什么是覆盖索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-什么是覆盖索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("7.1")]),_._v(" "),s("strong",[_._v("什么是覆盖索引？")])]),_._v(" "),s("p",[s("strong",[_._v("理解方式一")]),_._v("：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。"),s("strong",[_._v("一个索引包含了满足查询结果的数据就叫做覆盖索引。")])]),_._v(" "),s("p",[s("strong",[_._v("理解方式二")]),_._v("：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。")]),_._v(" "),s("p",[_._v("简单说就是，"),s("code",[_._v("索引列+主键")]),_._v("包含"),s("code",[_._v("SELECT 到 FROM之间查询的列")]),_._v("。")]),_._v(" "),s("h3",{attrs:{id:"_7-2-覆盖索引的利弊"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-覆盖索引的利弊"}},[_._v("#")]),_._v(" "),s("strong",[_._v("7.2")]),_._v(" "),s("strong",[_._v("覆盖索引的利弊")])]),_._v(" "),s("p",[s("strong",[_._v("好处：")])]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("避免Innodb表进行索引的二次查询（回表）")])]),_._v(" "),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("可以把随机IO变成顺序IO加快查询效率")])]),_._v(" "),s("p",[s("strong",[_._v("弊端：")])]),_._v(" "),s("p",[s("code",[_._v("索引字段的维护")]),_._v("总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。")]),_._v(" "),s("h2",{attrs:{id:"_8-索引条件下推"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-索引条件下推"}},[_._v("#")]),_._v(" "),s("strong",[_._v("8.")]),_._v(" "),s("strong",[_._v("索引条件下推")])]),_._v(" "),s("h3",{attrs:{id:"_8-1-使用前后的扫描过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-使用前后的扫描过程"}},[_._v("#")]),_._v(" "),s("strong",[_._v("8.1")]),_._v(" "),s("strong",[_._v("使用前后的扫描过程")])]),_._v(" "),s("p",[s("strong",[_._v("在不使用ICP索引扫描的过程：")])]),_._v(" "),s("p",[_._v("storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层")]),_._v(" "),s("p",[_._v("server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。")]),_._v(" "),s("p",[s("strong",[_._v("使用ICP扫描的过程：")])]),_._v(" "),s("p",[_._v("storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。")]),_._v(" "),s("p",[_._v("server 层：对返回的数据，使用table filter条件做最后的过滤。")]),_._v(" "),s("h2",{attrs:{id:"_9-其它查询优化策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-其它查询优化策略"}},[_._v("#")]),_._v(" "),s("strong",[_._v("9.")]),_._v(" "),s("strong",[_._v("其它查询优化策略")])]),_._v(" "),s("h3",{attrs:{id:"_9-1-exists-和-in-的区分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-exists-和-in-的区分"}},[_._v("#")]),_._v(" "),s("strong",[_._v("9.1 EXISTS")]),_._v(" "),s("strong",[_._v("和")]),_._v(" "),s("strong",[_._v("IN")]),_._v(" "),s("strong",[_._v("的区分")])]),_._v(" "),s("p",[_._v("索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为"),s("code",[_._v("小表驱动大表")]),_._v("。")]),_._v(" "),s("h3",{attrs:{id:"_9-2-count-与count-具体字段-效率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-count-与count-具体字段-效率"}},[_._v("#")]),_._v(" "),s("strong",[_._v("9.2 COUNT(*)与COUNT(具体字段)效率")])]),_._v(" "),s("p",[s("strong",[_._v("环节1：")]),s("code",[_._v("COUNT(*)")]),_._v("和"),s("code",[_._v("COUNT(1)")]),_._v("都是对所有结果进行"),s("code",[_._v("COUNT")]),_._v("，"),s("code",[_._v("COUNT(*)")]),_._v("和"),s("code",[_._v("COUNT(1)")]),_._v("本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。")]),_._v(" "),s("p",[_._v("**环节2：**如果是MyISAM存储引擎，统计数据表的行数只需要"),s("code",[_._v("O(1)")]),_._v("的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了"),s("code",[_._v("row_count")]),_._v("值，而一致性则是由表级锁来保证的。")]),_._v(" "),s("p",[_._v("如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用"),s("code",[_._v("扫描全表")]),_._v("，是"),s("code",[_._v("O(n)")]),_._v("的复杂度，进行循环+计数的方式来完成统计。")]),_._v(" "),s("p",[_._v("**环节3：**在InnoDB引擎中，如果采用"),s("code",[_._v("COUNT(具体字段)")]),_._v("来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于"),s("code",[_._v("COUNT(*)")]),_._v("和"),s("code",[_._v("COUNT(1)")]),_._v("来说，它们不需要查找具体的行，只是统计行数，系统会"),s("code",[_._v("自动")]),_._v("采用占用空间更小的二级索引来进行统计。")]),_._v(" "),s("p",[_._v("如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。")]),_._v(" "),s("h3",{attrs:{id:"_9-3-关于select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-关于select"}},[_._v("#")]),_._v(" "),s("strong",[_._v("9.3")]),_._v(" "),s("strong",[_._v("关于SELECT(*)")])]),_._v(" "),s("p",[_._v("在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。原因：")]),_._v(" "),s("p",[_._v("① MySQL 在解析的过程中，会通过"),s("code",[_._v("查询数据字典")]),_._v('将"*"按序转换成所有列名，这会大大的耗费资源和时间。')]),_._v(" "),s("p",[_._v("② 无法使用"),s("code",[_._v("覆盖索引")])]),_._v(" "),s("h3",{attrs:{id:"_9-4-limit-1-对优化的影响"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-limit-1-对优化的影响"}},[_._v("#")]),_._v(" "),s("strong",[_._v("9.4 LIMIT 1")]),_._v(" "),s("strong",[_._v("对优化的影响")])]),_._v(" "),s("p",[_._v("针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上"),s("code",[_._v("LIMIT 1")]),_._v("的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。")]),_._v(" "),s("p",[_._v("如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上"),s("code",[_._v("LIMIT 1")]),_._v("了。")]),_._v(" "),s("h3",{attrs:{id:"_9-5-多使用commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-多使用commit"}},[_._v("#")]),_._v(" "),s("strong",[_._v("9.5")]),_._v(" "),s("strong",[_._v("多使用COMMIT")])]),_._v(" "),s("p",[_._v("只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。")]),_._v(" "),s("p",[_._v("COMMIT 所释放的资源：")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("回滚段上用于恢复数据的信息")])]),_._v(" "),s("li",[s("p",[_._v("被程序语句获得的锁")])]),_._v(" "),s("li",[s("p",[_._v("redo / undo log buffer 中的空间")])]),_._v(" "),s("li",[s("p",[_._v("管理上述 3 种资源中的内部花费")])])]),_._v(" "),s("h1",{attrs:{id:"第5章-数据库的设计规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第5章-数据库的设计规范"}},[_._v("#")]),_._v(" 第5章 数据库的设计规范")]),_._v(" "),s("h2",{attrs:{id:"_1-范-式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-范-式"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("范 式")])]),_._v(" "),s("h3",{attrs:{id:"_1-1-范式简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-范式简介"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.1")]),_._v(" "),s("strong",[_._v("范式简介")])]),_._v(" "),s("p",[_._v("**在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的"),s("code",[_._v("级别")]),_._v("。要想设计一个结构合理的关系型数据库，必须满足一定的范式。")]),_._v(" "),s("h3",{attrs:{id:"_1-2-范式都包括哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-范式都包括哪些"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.2")]),_._v(" "),s("strong",[_._v("范式都包括哪些")])]),_._v(" "),s("p",[_._v("目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是："),s("strong",[_._v("第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）")]),_._v("。")]),_._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png",alt:"image-20220403092826169"}})]),_._v(" "),s("h3",{attrs:{id:"_1-3-键和相关属性的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-键和相关属性的概念"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.3")]),_._v(" "),s("strong",[_._v("键和相关属性的概念")])]),_._v(" "),s("p",[_._v("这里有两个表：")]),_._v(" "),s("p",[s("code",[_._v("球员表(player)")]),_._v("：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号")]),_._v(" "),s("p",[s("code",[_._v("球队表(team)")]),_._v("：球队编号 | 主教练 | 球队所在地")]),_._v(" "),s("ul",[s("li",[s("code",[_._v("超键")]),_._v("：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。")]),_._v(" "),s("li",[s("code",[_._v("候选键")]),_._v("：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。")]),_._v(" "),s("li",[s("code",[_._v("主键")]),_._v("：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。")]),_._v(" "),s("li",[s("code",[_._v("外键")]),_._v("：球员表中的球队编号。")]),_._v(" "),s("li",[s("code",[_._v("主属性")]),_._v("、"),s("code",[_._v("非主属性")]),_._v("：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。")])]),_._v(" "),s("h3",{attrs:{id:"_1-4-第一范式-1st-nf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-第一范式-1st-nf"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.4")]),_._v(" "),s("strong",[_._v("第一范式(1st NF)")])]),_._v(" "),s("p",[_._v("第一范式主要是确保数据表中每个字段的值必须具有"),s("code",[_._v("原子性")]),_._v("，也就是说数据表中每个字段的值为"),s("code",[_._v("不可再次拆分")]),_._v("的最小数据单位。")]),_._v(" "),s("h3",{attrs:{id:"_1-5-第二范式-2nd-nf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-第二范式-2nd-nf"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.5")]),_._v(" "),s("strong",[_._v("第二范式(2nd NF)")])]),_._v(" "),s("p",[_._v("第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。")]),_._v(" "),s("h3",{attrs:{id:"_1-6-第三范式-3rd-nf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-第三范式-3rd-nf"}},[_._v("#")]),_._v(" "),s("strong",[_._v("1.6")]),_._v(" "),s("strong",[_._v("第三范式(3rd NF)")])]),_._v(" "),s("p",[_._v("第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，"),s("strong",[_._v("要求数据表中的所有非主键字段不能依赖于其他非主键字段。")]),_._v('（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在"A--\x3eB--\x3eC"的决定关系）通俗地讲，该规则的意思是所有'),s("code",[_._v("非主键属性")]),_._v("之间不能有依赖关系，必须"),s("code",[_._v("相互独立")]),_._v("。")]),_._v(" "),s("h3",{attrs:{id:"_1-7-小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-小结"}},[_._v("#")]),_._v(" 1.7 小结")]),_._v(" "),s("p",[_._v("关于数据表的设计，有三个范式要遵循。")]),_._v(" "),s("p",[_._v("（1）第一范式（1NF），确保每列保持"),s("code",[_._v("原子性")])]),_._v(" "),s("p",[_._v("数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。")]),_._v(" "),s("p",[_._v("（2）第二范式（2NF），确保每列都和主键"),s("code",[_._v("完全依赖")])]),_._v(" "),s("p",[_._v("尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。")]),_._v(" "),s("p",[_._v("（3）第三范式（3NF），确保每列都和主键"),s("code",[_._v("直接相关")]),_._v("，而不是间接相关")]),_._v(" "),s("p",[_._v("**范式的优点：**数据的标准化有助于消除数据库中的"),s("code",[_._v("数据冗余")]),_._v("，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。")]),_._v(" "),s("p",[_._v("**范式的缺点：**范式的使用，可能"),s("code",[_._v("降低查询的效率")]),_._v("。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要"),s("code",[_._v("关联多张表")]),_._v("，这不但代价昂贵，也可能使一些"),s("code",[_._v("索引策略无效")]),_._v("。")]),_._v(" "),s("p",[_._v("范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过"),s("code",[_._v("增加少量的冗余")]),_._v("或重复的数据来提高数据库的"),s("code",[_._v("读性能")]),_._v("，减少关联查询，join表的次数，实现"),s("code",[_._v("空间换取时间")]),_._v("的目的。因此在实际的设计过程中要理论结合实际，灵活运用。")]),_._v(" "),s("h2",{attrs:{id:"_2-反范式化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-反范式化"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("反范式化")])]),_._v(" "),s("h3",{attrs:{id:"_2-1-概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-概述"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.1")]),_._v(" "),s("strong",[_._v("概述")])]),_._v(" "),s("p",[s("strong",[_._v("规范化")]),_._v(" "),s("strong",[_._v("vs")]),_._v(" "),s("strong",[_._v("性能")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("为满足某种商业目标 , 数据库性能比规范化数据库更重要")])]),_._v(" "),s("li",[s("p",[_._v("在数据规范化的同时 , 要综合考虑数据库的性能")])]),_._v(" "),s("li",[s("p",[_._v("通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间")])]),_._v(" "),s("li",[s("p",[_._v("通过在给定的表中插入计算列，以方便查询")])])]),_._v(" "),s("h3",{attrs:{id:"_2-2-反范式的新问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-反范式的新问题"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.2")]),_._v(" "),s("strong",[_._v("反范式的新问题")])]),_._v(" "),s("ul",[s("li",[_._v("存储"),s("code",[_._v("空间变大")]),_._v("了")]),_._v(" "),s("li",[_._v("一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则"),s("code",[_._v("数据不一致")])]),_._v(" "),s("li",[_._v("若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常"),s("code",[_._v("消耗系统资源")])]),_._v(" "),s("li",[_._v("在"),s("code",[_._v("数据量小")]),_._v("的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加"),s("code",[_._v("复杂")])])]),_._v(" "),s("h3",{attrs:{id:"_2-3-反范式的适用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-反范式的适用场景"}},[_._v("#")]),_._v(" "),s("strong",[_._v("2.3")]),_._v(" "),s("strong",[_._v("反范式的适用场景")])]),_._v(" "),s("p",[_._v("当冗余信息有价值或者能"),s("code",[_._v("大幅度提高查询效率")]),_._v("的时候，我们才会采取反范式的优化。")]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("增加冗余字段的建议")])]),_._v(" "),s("p",[_._v("1）这个冗余字段"),s("code",[_._v("不需要经常进行修改")])]),_._v(" "),s("p",[_._v("2）这个冗余字段"),s("code",[_._v("查询的时候不可或缺")])]),_._v(" "),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("历史快照、历史数据的需要")])]),_._v(" "),s("p",[_._v("在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的"),s("code",[_._v("订单收货信息")]),_._v("都属于"),s("code",[_._v("历史快照")]),_._v("，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。")]),_._v(" "),s("p",[_._v("反范式优化也常用在"),s("code",[_._v("数据仓库")]),_._v("的设计中，因为数据仓库通常"),s("code",[_._v("存储历史数据")]),_._v("，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。")]),_._v(" "),s("h2",{attrs:{id:"_3-bcnf-巴斯范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-bcnf-巴斯范式"}},[_._v("#")]),_._v(" "),s("strong",[_._v("3. BCNF(巴斯范式)")])]),_._v(" "),s("p",[_._v("主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，"),s("strong",[_._v("它在")]),_._v(" "),s("strong",[_._v("3NF")]),_._v(" "),s("strong",[_._v("的基础上消除了主属性对候选键的部分依赖或者传递依赖关系")]),_._v("。")]),_._v(" "),s("p",[_._v("如果在关系R中，U为主键，A属性是主键的一个属性，若存在A->Y，Y为主属性，则该关系不属于BCNF。")]),_._v(" "),s("h2",{attrs:{id:"_4-er模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-er模型"}},[_._v("#")]),_._v(" "),s("strong",[_._v("4. ER模型")])]),_._v(" "),s("p",[_._v("ER模型也叫做"),s("code",[_._v("实体关系模型")]),_._v("，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。"),s("strong",[_._v("在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。")])]),_._v(" "),s("h3",{attrs:{id:"_4-1-er-模型包括那些要素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-er-模型包括那些要素"}},[_._v("#")]),_._v(" 4.1 ER 模型包括那些要素？")]),_._v(" "),s("p",[s("strong",[_._v("ER")]),_._v(" "),s("strong",[_._v("模型中有三个要素，分别是实体、属性和关系")]),_._v("。")]),_._v(" "),s("p",[s("code",[_._v("实体")]),_._v("，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用"),s("code",[_._v("矩形")]),_._v("来表示。实体分为两类，分别是"),s("code",[_._v("强实体")]),_._v("和"),s("code",[_._v("弱实体")]),_._v("。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。")]),_._v(" "),s("p",[s("code",[_._v("属性")]),_._v("，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用"),s("code",[_._v("椭圆形")]),_._v("来表示。")]),_._v(" "),s("p",[s("code",[_._v("关系")]),_._v("，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用"),s("code",[_._v("菱形")]),_._v("来表示。")]),_._v(" "),s("p",[_._v("注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，"),s("strong",[_._v("可以独立存在的是实体，不可再分的是属性")]),_._v("。也就是说，属性不能包含其他属性。")]),_._v(" "),s("h3",{attrs:{id:"_4-2-关系的类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-关系的类型"}},[_._v("#")]),_._v(" "),s("strong",[_._v("4.2")]),_._v(" "),s("strong",[_._v("关系的类型")])]),_._v(" "),s("p",[_._v("在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。")]),_._v(" "),s("p",[s("code",[_._v("一对一")]),_._v("：指实体之间的关系是一一对应的")]),_._v(" "),s("p",[s("code",[_._v("一对多")]),_._v("：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体")]),_._v(" "),s("p",[s("code",[_._v("多对多")]),_._v("：指关系两边的实体都可以通过关系对应多个对方的实体")]),_._v(" "),s("h2",{attrs:{id:"_5-数据表的设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据表的设计原则"}},[_._v("#")]),_._v(" "),s("strong",[_._v("5.")]),_._v(" "),s("strong",[_._v("数据表的设计原则")])]),_._v(" "),s("p",[_._v('数据表设计的一般原则："三少一多"')]),_._v(" "),s("p",[s("strong",[_._v("1.")]),_._v(" "),s("strong",[_._v("数据表的个数越少越好")])]),_._v(" "),s("p",[s("strong",[_._v("2.")]),_._v(" "),s("strong",[_._v("数据表中的字段个数越少越好")])]),_._v(" "),s("p",[s("strong",[_._v("3.")]),_._v(" "),s("strong",[_._v("数据表中联合主键的字段个数越少越好")])]),_._v(" "),s("p",[s("strong",[_._v("4.")]),_._v(" "),s("strong",[_._v("使用主键和外键越多越好")])]),_._v(" "),s("blockquote",[s("p",[_._v("注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。")])]),_._v(" "),s("h2",{attrs:{id:"_6-数据库对象编写建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-数据库对象编写建议"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.")]),_._v(" "),s("strong",[_._v("数据库对象编写建议")])]),_._v(" "),s("h3",{attrs:{id:"_6-1-关于库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-关于库"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.1")]),_._v(" "),s("strong",[_._v("关于库")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】库名中英文"),s("code",[_._v("一律小写")]),_._v("，不同单词采用"),s("code",[_._v("下划线")]),_._v("分割。须见名知意。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】库的名称格式：业务系统名称_子系统名。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】库名禁止使用关键字（如type,order等）。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】创建数据库时必须"),s("code",[_._v("显式指定字符集")]),_._v("，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund "),s("code",[_._v("DEFAULT CHARACTER SET 'utf8'")]),_._v(";")])]),_._v(" "),s("li",[s("p",[_._v("【建议】对于程序连接数据库账号，遵循"),s("code",[_._v("权限最小原则")]),_._v("。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号"),s("code",[_._v("原则上不准有drop权限")]),_._v("。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】临时库以"),s("code",[_._v("tmp_")]),_._v("为前缀，并以日期为后缀；备份库以"),s("code",[_._v("bak_")]),_._v("为前缀，并以日期为后缀。")])])]),_._v(" "),s("h3",{attrs:{id:"_6-2-关于表、列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-关于表、列"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.2")]),_._v(" "),s("strong",[_._v("关于表、列")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以"),s("code",[_._v("英文字母开头")]),_._v("。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】 "),s("code",[_._v("表名、列名一律小写")]),_._v("，不同单词采用下划线分割。须见名知意。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】表名要求有模块名强相关，同一模块的表名尽量使用"),s("code",[_._v("统一前缀")]),_._v("。比如：crm_fund_item")])]),_._v(" "),s("li",[s("p",[_._v("【强制】创建表时必须"),s("code",[_._v("显式指定字符集")]),_._v("为utf8或utf8mb4。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】表名、列名禁止使用关键字（如type,order等）。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】创建表时必须"),s("code",[_._v("显式指定表存储引擎")]),_._v("类型。如无特殊需求，一律为InnoDB。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】建表必须有comment。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】字段命名应尽可能使用表达实际含义的英文单词或"),s("code",[_._v("缩写")]),_._v("。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】布尔值类型的字段命名为"),s("code",[_._v("is_描述")]),_._v("。如member表上表示是否为enabled的会员的字段命名为 is_enabled。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】建表时关于主键："),s("code",[_._v("表必须有主键")]),_._v("(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】核心表（如用户表）必须有行数据的"),s("code",[_._v("创建时间字段")]),_._v("（create_time）和"),s("code",[_._v("最后更新时间字段")]),_._v("（update_time），便于查问题。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】表中所有字段尽量都是"),s("code",[_._v("NOT NULL")]),_._v("属性，业务可以根据需要定义"),s("code",[_._v("DEFAULT值")]),_._v("。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】所有存储相同数据的"),s("code",[_._v("列名和列类型必须一致")]),_._v("（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】中间表（或临时表）用于保留中间结果集，名称以"),s("code",[_._v("tmp_")]),_._v("开头。备份表用于备份或抓取源表快照，名称以"),s("code",[_._v("bak_")]),_._v("开头。中间表和备份表定期清理。")])]),_._v(" "),s("li",[s("p",[_._v("【示范】一个较为规范的建表语句：")])])]),_._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("CREATE TABLE user_info ( \n    `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键', \n    `user_id` bigint(11) NOT NULL COMMENT '用户id', \n    `username` varchar(45) NOT NULL COMMENT '真实姓名', \n    `email` varchar(30) NOT NULL COMMENT '用户邮箱', \n    `nickname` varchar(45) NOT NULL COMMENT '昵称', \n    `birthday` date NOT NULL COMMENT '生日', \n    `sex` tinyint(4) DEFAULT '0' COMMENT '性别', \n    `short_introduce` varchar(150) DEFAULT NULL COMMENT '一句话介绍自己，最多50个汉字', \n    `user_resume` varchar(300) NOT NULL COMMENT '用户提交的简历存放地址', \n    `user_register_ip` int NOT NULL COMMENT '用户注册时的源ip', \n    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', \n    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间', \n    `user_review_status` tinyint NOT NULL COMMENT '用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核',\n    PRIMARY KEY (`id`), \n    UNIQUE KEY `uniq_user_id` (`user_id`), \n    KEY `idx_username`(`username`), \n    KEY `idx_create_time_status`(`create_time`,`user_review_status`) \n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='网站用户基本信息'\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br"),s("span",{staticClass:"line-number"},[_._v("8")]),s("br"),s("span",{staticClass:"line-number"},[_._v("9")]),s("br"),s("span",{staticClass:"line-number"},[_._v("10")]),s("br"),s("span",{staticClass:"line-number"},[_._v("11")]),s("br"),s("span",{staticClass:"line-number"},[_._v("12")]),s("br"),s("span",{staticClass:"line-number"},[_._v("13")]),s("br"),s("span",{staticClass:"line-number"},[_._v("14")]),s("br"),s("span",{staticClass:"line-number"},[_._v("15")]),s("br"),s("span",{staticClass:"line-number"},[_._v("16")]),s("br"),s("span",{staticClass:"line-number"},[_._v("17")]),s("br"),s("span",{staticClass:"line-number"},[_._v("18")]),s("br"),s("span",{staticClass:"line-number"},[_._v("19")]),s("br")])]),s("ol",{attrs:{start:"17"}},[s("li",[_._v("【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。")])]),_._v(" "),s("h3",{attrs:{id:"_6-3-关于索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-关于索引"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.3")]),_._v(" "),s("strong",[_._v("关于索引")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值"),s("code",[_._v("禁止被更新")]),_._v("。")])]),_._v(" "),s("li",[s("p",[_._v("【强制】InnoDB和MyISAM存储引擎表，索引类型必须为"),s("code",[_._v("BTREE")]),_._v("。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】主键的名称以"),s("code",[_._v("pk_")]),_._v("开头，唯一键以"),s("code",[_._v("uni_")]),_._v("或"),s("code",[_._v("uk_")]),_._v("开头，普通索引以"),s("code",[_._v("idx_")]),_._v("开头，一律使用小写格式，以字段的名称或缩写作为后缀。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】单个表上的索引个数"),s("code",[_._v("不能超过6个")]),_._v("。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】在建立索引时，多考虑建立"),s("code",[_._v("联合索引")]),_._v("，并把区分度最高的字段放在最前面。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】建表或加索引时，保证表里互相不存在"),s("code",[_._v("冗余索引")]),_._v("。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。")])])]),_._v(" "),s("h3",{attrs:{id:"_6-4-sql编写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-sql编写"}},[_._v("#")]),_._v(" "),s("strong",[_._v("6.4 SQL编写")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】线上环境，多表 JOIN 不要超过5个表。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生"),s("code",[_._v("表锁")]),_._v("，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。")])]),_._v(" "),s("li",[s("p",[_._v("【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。")])])]),_._v(" "),s("h1",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])])])}),[],!1,null,null,null);v.default=e.exports}}]);